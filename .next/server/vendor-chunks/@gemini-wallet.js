"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@gemini-wallet";
exports.ids = ["vendor-chunks/@gemini-wallet"];
exports.modules = {

/***/ "(ssr)/./node_modules/@gemini-wallet/core/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@gemini-wallet/core/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Communicator: () => (/* binding */ Communicator),\n/* harmony export */   DEFAULT_CHAIN_ID: () => (/* binding */ DEFAULT_CHAIN_ID),\n/* harmony export */   GeminiSdkEvent: () => (/* binding */ GeminiSdkEvent),\n/* harmony export */   GeminiStorage: () => (/* binding */ GeminiStorage),\n/* harmony export */   GeminiWallet: () => (/* binding */ GeminiWallet),\n/* harmony export */   GeminiWalletProvider: () => (/* binding */ GeminiWalletProvider),\n/* harmony export */   POPUP_HEIGHT: () => (/* binding */ POPUP_HEIGHT),\n/* harmony export */   POPUP_WIDTH: () => (/* binding */ POPUP_WIDTH),\n/* harmony export */   ProviderEventEmitter: () => (/* binding */ ProviderEventEmitter),\n/* harmony export */   SDK_BACKEND_URL: () => (/* binding */ SDK_BACKEND_URL),\n/* harmony export */   SDK_VERSION: () => (/* binding */ SDK_VERSION),\n/* harmony export */   STORAGE_ETH_ACCOUNTS_KEY: () => (/* binding */ STORAGE_ETH_ACCOUNTS_KEY),\n/* harmony export */   STORAGE_ETH_ACTIVE_CHAIN_KEY: () => (/* binding */ STORAGE_ETH_ACTIVE_CHAIN_KEY),\n/* harmony export */   STORAGE_PASSKEY_CREDENTIAL_KEY: () => (/* binding */ STORAGE_PASSKEY_CREDENTIAL_KEY),\n/* harmony export */   STORAGE_SETTINGS_KEY: () => (/* binding */ STORAGE_SETTINGS_KEY),\n/* harmony export */   STORAGE_SMART_ACCOUNT_KEY: () => (/* binding */ STORAGE_SMART_ACCOUNT_KEY),\n/* harmony export */   base64ToHex: () => (/* binding */ base64ToHex),\n/* harmony export */   bufferToBase64URLString: () => (/* binding */ bufferToBase64URLString),\n/* harmony export */   closePopup: () => (/* binding */ closePopup),\n/* harmony export */   convertSendValuesToBigInt: () => (/* binding */ convertSendValuesToBigInt),\n/* harmony export */   decodeBase64: () => (/* binding */ decodeBase64),\n/* harmony export */   encodeBase64: () => (/* binding */ encodeBase64),\n/* harmony export */   fetchRpcRequest: () => (/* binding */ fetchRpcRequest),\n/* harmony export */   generateRequestId: () => (/* binding */ generateRequestId),\n/* harmony export */   hexStringFromNumber: () => (/* binding */ hexStringFromNumber),\n/* harmony export */   openPopup: () => (/* binding */ openPopup),\n/* harmony export */   safeJsonStringify: () => (/* binding */ safeJsonStringify),\n/* harmony export */   utf8StringToBuffer: () => (/* binding */ utf8StringToBuffer),\n/* harmony export */   validateRpcRequestArgs: () => (/* binding */ validateRpcRequestArgs)\n/* harmony export */ });\nvar __create = Object.create;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __toESM = (mod, isNodeMode, target) => {\n  target = mod != null ? __create(__getProtoOf(mod)) : {};\n  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target;\n  for (let key of __getOwnPropNames(mod))\n    if (!__hasOwnProp.call(to, key))\n      __defProp(to, key, {\n        get: () => mod[key],\n        enumerable: true\n      });\n  return to;\n};\nvar __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);\n\n// node_modules/fast-safe-stringify/index.js\nvar require_fast_safe_stringify = __commonJS((exports, module) => {\n  module.exports = stringify;\n  stringify.default = stringify;\n  stringify.stable = deterministicStringify;\n  stringify.stableStringify = deterministicStringify;\n  var LIMIT_REPLACE_NODE = \"[...]\";\n  var CIRCULAR_REPLACE_NODE = \"[Circular]\";\n  var arr = [];\n  var replacerStack = [];\n  function defaultOptions() {\n    return {\n      depthLimit: Number.MAX_SAFE_INTEGER,\n      edgesLimit: Number.MAX_SAFE_INTEGER\n    };\n  }\n  function stringify(obj, replacer, spacer, options) {\n    if (typeof options === \"undefined\") {\n      options = defaultOptions();\n    }\n    decirc(obj, \"\", 0, [], undefined, 0, options);\n    var res;\n    try {\n      if (replacerStack.length === 0) {\n        res = JSON.stringify(obj, replacer, spacer);\n      } else {\n        res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);\n      }\n    } catch (_) {\n      return JSON.stringify(\"[unable to serialize, circular reference is too complex to analyze]\");\n    } finally {\n      while (arr.length !== 0) {\n        var part = arr.pop();\n        if (part.length === 4) {\n          Object.defineProperty(part[0], part[1], part[3]);\n        } else {\n          part[0][part[1]] = part[2];\n        }\n      }\n    }\n    return res;\n  }\n  function setReplace(replace, val, k, parent) {\n    var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);\n    if (propertyDescriptor.get !== undefined) {\n      if (propertyDescriptor.configurable) {\n        Object.defineProperty(parent, k, { value: replace });\n        arr.push([parent, k, val, propertyDescriptor]);\n      } else {\n        replacerStack.push([val, k, replace]);\n      }\n    } else {\n      parent[k] = replace;\n      arr.push([parent, k, val]);\n    }\n  }\n  function decirc(val, k, edgeIndex, stack, parent, depth, options) {\n    depth += 1;\n    var i;\n    if (typeof val === \"object\" && val !== null) {\n      for (i = 0;i < stack.length; i++) {\n        if (stack[i] === val) {\n          setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);\n          return;\n        }\n      }\n      if (typeof options.depthLimit !== \"undefined\" && depth > options.depthLimit) {\n        setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n        return;\n      }\n      if (typeof options.edgesLimit !== \"undefined\" && edgeIndex + 1 > options.edgesLimit) {\n        setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n        return;\n      }\n      stack.push(val);\n      if (Array.isArray(val)) {\n        for (i = 0;i < val.length; i++) {\n          decirc(val[i], i, i, stack, val, depth, options);\n        }\n      } else {\n        var keys = Object.keys(val);\n        for (i = 0;i < keys.length; i++) {\n          var key = keys[i];\n          decirc(val[key], key, i, stack, val, depth, options);\n        }\n      }\n      stack.pop();\n    }\n  }\n  function compareFunction(a, b) {\n    if (a < b) {\n      return -1;\n    }\n    if (a > b) {\n      return 1;\n    }\n    return 0;\n  }\n  function deterministicStringify(obj, replacer, spacer, options) {\n    if (typeof options === \"undefined\") {\n      options = defaultOptions();\n    }\n    var tmp = deterministicDecirc(obj, \"\", 0, [], undefined, 0, options) || obj;\n    var res;\n    try {\n      if (replacerStack.length === 0) {\n        res = JSON.stringify(tmp, replacer, spacer);\n      } else {\n        res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);\n      }\n    } catch (_) {\n      return JSON.stringify(\"[unable to serialize, circular reference is too complex to analyze]\");\n    } finally {\n      while (arr.length !== 0) {\n        var part = arr.pop();\n        if (part.length === 4) {\n          Object.defineProperty(part[0], part[1], part[3]);\n        } else {\n          part[0][part[1]] = part[2];\n        }\n      }\n    }\n    return res;\n  }\n  function deterministicDecirc(val, k, edgeIndex, stack, parent, depth, options) {\n    depth += 1;\n    var i;\n    if (typeof val === \"object\" && val !== null) {\n      for (i = 0;i < stack.length; i++) {\n        if (stack[i] === val) {\n          setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);\n          return;\n        }\n      }\n      try {\n        if (typeof val.toJSON === \"function\") {\n          return;\n        }\n      } catch (_) {\n        return;\n      }\n      if (typeof options.depthLimit !== \"undefined\" && depth > options.depthLimit) {\n        setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n        return;\n      }\n      if (typeof options.edgesLimit !== \"undefined\" && edgeIndex + 1 > options.edgesLimit) {\n        setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n        return;\n      }\n      stack.push(val);\n      if (Array.isArray(val)) {\n        for (i = 0;i < val.length; i++) {\n          deterministicDecirc(val[i], i, i, stack, val, depth, options);\n        }\n      } else {\n        var tmp = {};\n        var keys = Object.keys(val).sort(compareFunction);\n        for (i = 0;i < keys.length; i++) {\n          var key = keys[i];\n          deterministicDecirc(val[key], key, i, stack, val, depth, options);\n          tmp[key] = val[key];\n        }\n        if (typeof parent !== \"undefined\") {\n          arr.push([parent, k, val]);\n          parent[k] = tmp;\n        } else {\n          return tmp;\n        }\n      }\n      stack.pop();\n    }\n  }\n  function replaceGetterValues(replacer) {\n    replacer = typeof replacer !== \"undefined\" ? replacer : function(k, v) {\n      return v;\n    };\n    return function(key, val) {\n      if (replacerStack.length > 0) {\n        for (var i = 0;i < replacerStack.length; i++) {\n          var part = replacerStack[i];\n          if (part[1] === key && part[0] === val) {\n            val = part[2];\n            replacerStack.splice(i, 1);\n            break;\n          }\n        }\n      }\n      return replacer.call(this, key, val);\n    };\n  }\n});\n\n// node_modules/eventemitter3/index.js\nvar require_eventemitter3 = __commonJS((exports, module) => {\n  var has = Object.prototype.hasOwnProperty;\n  var prefix = \"~\";\n  function Events() {}\n  if (Object.create) {\n    Events.prototype = Object.create(null);\n    if (!new Events().__proto__)\n      prefix = false;\n  }\n  function EE(fn, context, once) {\n    this.fn = fn;\n    this.context = context;\n    this.once = once || false;\n  }\n  function addListener(emitter, event, fn, context, once) {\n    if (typeof fn !== \"function\") {\n      throw new TypeError(\"The listener must be a function\");\n    }\n    var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;\n    if (!emitter._events[evt])\n      emitter._events[evt] = listener, emitter._eventsCount++;\n    else if (!emitter._events[evt].fn)\n      emitter._events[evt].push(listener);\n    else\n      emitter._events[evt] = [emitter._events[evt], listener];\n    return emitter;\n  }\n  function clearEvent(emitter, evt) {\n    if (--emitter._eventsCount === 0)\n      emitter._events = new Events;\n    else\n      delete emitter._events[evt];\n  }\n  function EventEmitter() {\n    this._events = new Events;\n    this._eventsCount = 0;\n  }\n  EventEmitter.prototype.eventNames = function eventNames() {\n    var names = [], events, name;\n    if (this._eventsCount === 0)\n      return names;\n    for (name in events = this._events) {\n      if (has.call(events, name))\n        names.push(prefix ? name.slice(1) : name);\n    }\n    if (Object.getOwnPropertySymbols) {\n      return names.concat(Object.getOwnPropertySymbols(events));\n    }\n    return names;\n  };\n  EventEmitter.prototype.listeners = function listeners(event) {\n    var evt = prefix ? prefix + event : event, handlers = this._events[evt];\n    if (!handlers)\n      return [];\n    if (handlers.fn)\n      return [handlers.fn];\n    for (var i = 0, l = handlers.length, ee = new Array(l);i < l; i++) {\n      ee[i] = handlers[i].fn;\n    }\n    return ee;\n  };\n  EventEmitter.prototype.listenerCount = function listenerCount(event) {\n    var evt = prefix ? prefix + event : event, listeners = this._events[evt];\n    if (!listeners)\n      return 0;\n    if (listeners.fn)\n      return 1;\n    return listeners.length;\n  };\n  EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n    var evt = prefix ? prefix + event : event;\n    if (!this._events[evt])\n      return false;\n    var listeners = this._events[evt], len = arguments.length, args, i;\n    if (listeners.fn) {\n      if (listeners.once)\n        this.removeListener(event, listeners.fn, undefined, true);\n      switch (len) {\n        case 1:\n          return listeners.fn.call(listeners.context), true;\n        case 2:\n          return listeners.fn.call(listeners.context, a1), true;\n        case 3:\n          return listeners.fn.call(listeners.context, a1, a2), true;\n        case 4:\n          return listeners.fn.call(listeners.context, a1, a2, a3), true;\n        case 5:\n          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n        case 6:\n          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n      }\n      for (i = 1, args = new Array(len - 1);i < len; i++) {\n        args[i - 1] = arguments[i];\n      }\n      listeners.fn.apply(listeners.context, args);\n    } else {\n      var length = listeners.length, j;\n      for (i = 0;i < length; i++) {\n        if (listeners[i].once)\n          this.removeListener(event, listeners[i].fn, undefined, true);\n        switch (len) {\n          case 1:\n            listeners[i].fn.call(listeners[i].context);\n            break;\n          case 2:\n            listeners[i].fn.call(listeners[i].context, a1);\n            break;\n          case 3:\n            listeners[i].fn.call(listeners[i].context, a1, a2);\n            break;\n          case 4:\n            listeners[i].fn.call(listeners[i].context, a1, a2, a3);\n            break;\n          default:\n            if (!args)\n              for (j = 1, args = new Array(len - 1);j < len; j++) {\n                args[j - 1] = arguments[j];\n              }\n            listeners[i].fn.apply(listeners[i].context, args);\n        }\n      }\n    }\n    return true;\n  };\n  EventEmitter.prototype.on = function on(event, fn, context) {\n    return addListener(this, event, fn, context, false);\n  };\n  EventEmitter.prototype.once = function once(event, fn, context) {\n    return addListener(this, event, fn, context, true);\n  };\n  EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n    var evt = prefix ? prefix + event : event;\n    if (!this._events[evt])\n      return this;\n    if (!fn) {\n      clearEvent(this, evt);\n      return this;\n    }\n    var listeners = this._events[evt];\n    if (listeners.fn) {\n      if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {\n        clearEvent(this, evt);\n      }\n    } else {\n      for (var i = 0, events = [], length = listeners.length;i < length; i++) {\n        if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {\n          events.push(listeners[i]);\n        }\n      }\n      if (events.length)\n        this._events[evt] = events.length === 1 ? events[0] : events;\n      else\n        clearEvent(this, evt);\n    }\n    return this;\n  };\n  EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n    var evt;\n    if (event) {\n      evt = prefix ? prefix + event : event;\n      if (this._events[evt])\n        clearEvent(this, evt);\n    } else {\n      this._events = new Events;\n      this._eventsCount = 0;\n    }\n    return this;\n  };\n  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n  EventEmitter.prototype.addListener = EventEmitter.prototype.on;\n  EventEmitter.prefixed = prefix;\n  EventEmitter.EventEmitter = EventEmitter;\n  if (typeof module !== \"undefined\") {\n    module.exports = EventEmitter;\n  }\n});\n\n// node_modules/viem/_esm/utils/data/isHex.js\nfunction isHex(value, { strict = true } = {}) {\n  if (!value)\n    return false;\n  if (typeof value !== \"string\")\n    return false;\n  return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith(\"0x\");\n}\n\n// node_modules/@metamask/superstruct/dist/error.mjs\nclass StructError extends TypeError {\n  constructor(failure, failures) {\n    let cached;\n    const { message, explanation, ...rest } = failure;\n    const { path } = failure;\n    const cause = path.length === 0 ? message : `At path: ${path.join(\".\")} -- ${message}`;\n    super(explanation ?? cause);\n    if (explanation !== null && explanation !== undefined) {\n      this.cause = cause;\n    }\n    Object.assign(this, rest);\n    this.name = this.constructor.name;\n    this.failures = () => {\n      return cached ?? (cached = [failure, ...failures()]);\n    };\n  }\n}\n\n// node_modules/@metamask/superstruct/dist/utils.mjs\nfunction isIterable(value) {\n  return isObject(value) && typeof value[Symbol.iterator] === \"function\";\n}\nfunction isObject(value) {\n  return typeof value === \"object\" && value !== null;\n}\nfunction print(value) {\n  if (typeof value === \"symbol\") {\n    return value.toString();\n  }\n  return typeof value === \"string\" ? JSON.stringify(value) : `${value}`;\n}\nfunction shiftIterator(input) {\n  const { done, value } = input.next();\n  return done ? undefined : value;\n}\nfunction toFailure(result, context, struct, value) {\n  if (result === true) {\n    return;\n  } else if (result === false) {\n    result = {};\n  } else if (typeof result === \"string\") {\n    result = { message: result };\n  }\n  const { path, branch } = context;\n  const { type } = struct;\n  const { refinement, message = `Expected a value of type \\`${type}\\`${refinement ? ` with refinement \\`${refinement}\\`` : \"\"}, but received: \\`${print(value)}\\`` } = result;\n  return {\n    value,\n    type,\n    refinement,\n    key: path[path.length - 1],\n    path,\n    branch,\n    ...result,\n    message\n  };\n}\nfunction* toFailures(result, context, struct, value) {\n  if (!isIterable(result)) {\n    result = [result];\n  }\n  for (const validationResult of result) {\n    const failure = toFailure(validationResult, context, struct, value);\n    if (failure) {\n      yield failure;\n    }\n  }\n}\nfunction* run(value, struct, options = {}) {\n  const { path = [], branch = [value], coerce = false, mask = false } = options;\n  const context = { path, branch };\n  if (coerce) {\n    value = struct.coercer(value, context);\n    if (mask && struct.type !== \"type\" && isObject(struct.schema) && isObject(value) && !Array.isArray(value)) {\n      for (const key in value) {\n        if (struct.schema[key] === undefined) {\n          delete value[key];\n        }\n      }\n    }\n  }\n  let status = \"valid\";\n  for (const failure of struct.validator(value, context)) {\n    failure.explanation = options.message;\n    status = \"not_valid\";\n    yield [failure, undefined];\n  }\n  for (let [innerKey, innerValue, innerStruct] of struct.entries(value, context)) {\n    const iterable = run(innerValue, innerStruct, {\n      path: innerKey === undefined ? path : [...path, innerKey],\n      branch: innerKey === undefined ? branch : [...branch, innerValue],\n      coerce,\n      mask,\n      message: options.message\n    });\n    for (const result of iterable) {\n      if (result[0]) {\n        status = result[0].refinement === null || result[0].refinement === undefined ? \"not_valid\" : \"not_refined\";\n        yield [result[0], undefined];\n      } else if (coerce) {\n        innerValue = result[1];\n        if (innerKey === undefined) {\n          value = innerValue;\n        } else if (value instanceof Map) {\n          value.set(innerKey, innerValue);\n        } else if (value instanceof Set) {\n          value.add(innerValue);\n        } else if (isObject(value)) {\n          if (innerValue !== undefined || innerKey in value) {\n            value[innerKey] = innerValue;\n          }\n        }\n      }\n    }\n  }\n  if (status !== \"not_valid\") {\n    for (const failure of struct.refiner(value, context)) {\n      failure.explanation = options.message;\n      status = \"not_refined\";\n      yield [failure, undefined];\n    }\n  }\n  if (status === \"valid\") {\n    yield [undefined, value];\n  }\n}\n\n// node_modules/@metamask/superstruct/dist/struct.mjs\nclass Struct {\n  constructor(props) {\n    const { type, schema, validator, refiner, coercer = (value) => value, entries = function* () {} } = props;\n    this.type = type;\n    this.schema = schema;\n    this.entries = entries;\n    this.coercer = coercer;\n    if (validator) {\n      this.validator = (value, context) => {\n        const result = validator(value, context);\n        return toFailures(result, context, this, value);\n      };\n    } else {\n      this.validator = () => [];\n    }\n    if (refiner) {\n      this.refiner = (value, context) => {\n        const result = refiner(value, context);\n        return toFailures(result, context, this, value);\n      };\n    } else {\n      this.refiner = () => [];\n    }\n  }\n  assert(value, message) {\n    return assert(value, this, message);\n  }\n  create(value, message) {\n    return create(value, this, message);\n  }\n  is(value) {\n    return is(value, this);\n  }\n  mask(value, message) {\n    return mask(value, this, message);\n  }\n  validate(value, options = {}) {\n    return validate(value, this, options);\n  }\n}\nvar ExactOptionalBrand = \"EXACT_OPTIONAL\";\n\nclass ExactOptionalStruct extends Struct {\n  constructor(props) {\n    super({\n      ...props,\n      type: `exact optional ${props.type}`\n    });\n    this.brand = ExactOptionalBrand;\n  }\n  static isExactOptional(value) {\n    return isObject(value) && \"brand\" in value && value.brand === ExactOptionalBrand;\n  }\n}\nfunction assert(value, struct, message) {\n  const result = validate(value, struct, { message });\n  if (result[0]) {\n    throw result[0];\n  }\n}\nfunction create(value, struct, message) {\n  const result = validate(value, struct, { coerce: true, message });\n  if (result[0]) {\n    throw result[0];\n  } else {\n    return result[1];\n  }\n}\nfunction mask(value, struct, message) {\n  const result = validate(value, struct, { coerce: true, mask: true, message });\n  if (result[0]) {\n    throw result[0];\n  } else {\n    return result[1];\n  }\n}\nfunction is(value, struct) {\n  const result = validate(value, struct);\n  return !result[0];\n}\nfunction validate(value, struct, options = {}) {\n  const tuples = run(value, struct, options);\n  const tuple = shiftIterator(tuples);\n  if (tuple[0]) {\n    const error = new StructError(tuple[0], function* () {\n      for (const innerTuple of tuples) {\n        if (innerTuple[0]) {\n          yield innerTuple[0];\n        }\n      }\n    });\n    return [error, undefined];\n  }\n  const validatedValue = tuple[1];\n  return [undefined, validatedValue];\n}\n\n// node_modules/@metamask/superstruct/dist/structs/utilities.mjs\nfunction define(name, validator) {\n  return new Struct({ type: name, schema: null, validator });\n}\n\n// node_modules/@metamask/superstruct/dist/structs/types.mjs\nfunction any() {\n  return define(\"any\", () => true);\n}\nfunction array(Element) {\n  return new Struct({\n    type: \"array\",\n    schema: Element,\n    *entries(value) {\n      if (Element && Array.isArray(value)) {\n        for (const [index, arrayValue] of value.entries()) {\n          yield [index, arrayValue, Element];\n        }\n      }\n    },\n    coercer(value) {\n      return Array.isArray(value) ? value.slice() : value;\n    },\n    validator(value) {\n      return Array.isArray(value) || `Expected an array value, but received: ${print(value)}`;\n    }\n  });\n}\nfunction integer() {\n  return define(\"integer\", (value) => {\n    return typeof value === \"number\" && !isNaN(value) && Number.isInteger(value) || `Expected an integer, but received: ${print(value)}`;\n  });\n}\nfunction literal(constant) {\n  const description = print(constant);\n  const valueType = typeof constant;\n  return new Struct({\n    type: \"literal\",\n    schema: valueType === \"string\" || valueType === \"number\" || valueType === \"boolean\" ? constant : null,\n    validator(value) {\n      return value === constant || `Expected the literal \\`${description}\\`, but received: ${print(value)}`;\n    }\n  });\n}\nfunction never() {\n  return define(\"never\", () => false);\n}\nfunction nullable(struct) {\n  return new Struct({\n    ...struct,\n    validator: (value, ctx) => value === null || struct.validator(value, ctx),\n    refiner: (value, ctx) => value === null || struct.refiner(value, ctx)\n  });\n}\nfunction number() {\n  return define(\"number\", (value) => {\n    return typeof value === \"number\" && !isNaN(value) || `Expected a number, but received: ${print(value)}`;\n  });\n}\nfunction object(schema) {\n  const knowns = schema ? Object.keys(schema) : [];\n  const Never = never();\n  return new Struct({\n    type: \"object\",\n    schema: schema ?? null,\n    *entries(value) {\n      if (schema && isObject(value)) {\n        const unknowns = new Set(Object.keys(value));\n        for (const key of knowns) {\n          unknowns.delete(key);\n          const propertySchema = schema[key];\n          if (ExactOptionalStruct.isExactOptional(propertySchema) && !Object.prototype.hasOwnProperty.call(value, key)) {\n            continue;\n          }\n          yield [key, value[key], schema[key]];\n        }\n        for (const key of unknowns) {\n          yield [key, value[key], Never];\n        }\n      }\n    },\n    validator(value) {\n      return isObject(value) || `Expected an object, but received: ${print(value)}`;\n    },\n    coercer(value) {\n      return isObject(value) ? { ...value } : value;\n    }\n  });\n}\nfunction optional(struct) {\n  return new Struct({\n    ...struct,\n    validator: (value, ctx) => value === undefined || struct.validator(value, ctx),\n    refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx)\n  });\n}\nfunction record(Key, Value) {\n  return new Struct({\n    type: \"record\",\n    schema: null,\n    *entries(value) {\n      if (isObject(value)) {\n        for (const objectKey in value) {\n          const objectValue = value[objectKey];\n          yield [objectKey, objectKey, Key];\n          yield [objectKey, objectValue, Value];\n        }\n      }\n    },\n    validator(value) {\n      return isObject(value) || `Expected an object, but received: ${print(value)}`;\n    }\n  });\n}\nfunction string() {\n  return define(\"string\", (value) => {\n    return typeof value === \"string\" || `Expected a string, but received: ${print(value)}`;\n  });\n}\nfunction union(Structs) {\n  const description = Structs.map((struct) => struct.type).join(\" | \");\n  return new Struct({\n    type: \"union\",\n    schema: null,\n    coercer(value) {\n      for (const InnerStruct of Structs) {\n        const [error, coerced] = InnerStruct.validate(value, { coerce: true });\n        if (!error) {\n          return coerced;\n        }\n      }\n      return value;\n    },\n    validator(value, ctx) {\n      const failures = [];\n      for (const InnerStruct of Structs) {\n        const [...tuples] = run(value, InnerStruct, ctx);\n        const [first] = tuples;\n        if (!first?.[0]) {\n          return [];\n        }\n        for (const [failure] of tuples) {\n          if (failure) {\n            failures.push(failure);\n          }\n        }\n      }\n      return [\n        `Expected the value to satisfy a union of \\`${description}\\`, but received: ${print(value)}`,\n        ...failures\n      ];\n    }\n  });\n}\nfunction unknown() {\n  return define(\"unknown\", () => true);\n}\n\n// node_modules/@metamask/superstruct/dist/structs/coercions.mjs\nfunction coerce(struct, condition, coercer) {\n  return new Struct({\n    ...struct,\n    coercer: (value, ctx) => {\n      return is(value, condition) ? struct.coercer(coercer(value, ctx), ctx) : struct.coercer(value, ctx);\n    }\n  });\n}\n\n// node_modules/@metamask/superstruct/dist/structs/refinements.mjs\nfunction refine(struct, name, refiner) {\n  return new Struct({\n    ...struct,\n    *refiner(value, ctx) {\n      yield* struct.refiner(value, ctx);\n      const result = refiner(value, ctx);\n      const failures = toFailures(result, ctx, struct, value);\n      for (const failure of failures) {\n        yield { ...failure, refinement: name };\n      }\n    }\n  });\n}\n\n// node_modules/@metamask/utils/dist/misc.mjs\nfunction isObject2(value) {\n  return Boolean(value) && typeof value === \"object\" && !Array.isArray(value);\n}\nvar hasProperty = (objectToCheck, name) => Object.hasOwnProperty.call(objectToCheck, name);\nvar JsonSize;\n(function(JsonSize2) {\n  JsonSize2[JsonSize2[\"Null\"] = 4] = \"Null\";\n  JsonSize2[JsonSize2[\"Comma\"] = 1] = \"Comma\";\n  JsonSize2[JsonSize2[\"Wrapper\"] = 1] = \"Wrapper\";\n  JsonSize2[JsonSize2[\"True\"] = 4] = \"True\";\n  JsonSize2[JsonSize2[\"False\"] = 5] = \"False\";\n  JsonSize2[JsonSize2[\"Quote\"] = 1] = \"Quote\";\n  JsonSize2[JsonSize2[\"Colon\"] = 1] = \"Colon\";\n  JsonSize2[JsonSize2[\"Date\"] = 24] = \"Date\";\n})(JsonSize = JsonSize || (JsonSize = {}));\nfunction isPlainObject(value) {\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n  try {\n    let proto = value;\n    while (Object.getPrototypeOf(proto) !== null) {\n      proto = Object.getPrototypeOf(proto);\n    }\n    return Object.getPrototypeOf(value) === proto;\n  } catch (_) {\n    return false;\n  }\n}\n\n// node_modules/@metamask/utils/dist/json.mjs\nvar object2 = (schema) => object(schema);\nfunction hasOptional({ path, branch }) {\n  const field = path[path.length - 1];\n  return hasProperty(branch[branch.length - 2], field);\n}\nfunction exactOptional(struct) {\n  return new Struct({\n    ...struct,\n    type: `optional ${struct.type}`,\n    validator: (value, context) => !hasOptional(context) || struct.validator(value, context),\n    refiner: (value, context) => !hasOptional(context) || struct.refiner(value, context)\n  });\n}\nfunction validateJson(json) {\n  if (json === null || typeof json === \"boolean\" || typeof json === \"string\") {\n    return true;\n  }\n  if (typeof json === \"number\" && Number.isFinite(json)) {\n    return true;\n  }\n  if (typeof json === \"object\") {\n    let every = true;\n    if (Array.isArray(json)) {\n      for (let i = 0;i < json.length; i++) {\n        if (!validateJson(json[i])) {\n          every = false;\n          break;\n        }\n      }\n      return every;\n    }\n    const entries = Object.entries(json);\n    for (let i = 0;i < entries.length; i++) {\n      if (typeof entries[i][0] !== \"string\" || !validateJson(entries[i][1])) {\n        every = false;\n        break;\n      }\n    }\n    return every;\n  }\n  return false;\n}\nvar UnsafeJsonStruct = define(\"JSON\", (json) => validateJson(json));\nvar JsonStruct = coerce(UnsafeJsonStruct, refine(any(), \"JSON\", (value) => is(value, UnsafeJsonStruct)), (value) => JSON.parse(JSON.stringify(value, (propKey, propValue) => {\n  if (propKey === \"__proto__\" || propKey === \"constructor\") {\n    return;\n  }\n  return propValue;\n})));\nfunction isValidJson(value) {\n  try {\n    getSafeJson(value);\n    return true;\n  } catch {\n    return false;\n  }\n}\nfunction getSafeJson(value) {\n  return create(value, JsonStruct);\n}\nvar jsonrpc2 = \"2.0\";\nvar JsonRpcVersionStruct = literal(jsonrpc2);\nvar JsonRpcIdStruct = nullable(union([number(), string()]));\nvar JsonRpcErrorStruct = object2({\n  code: integer(),\n  message: string(),\n  data: exactOptional(JsonStruct),\n  stack: exactOptional(string())\n});\nvar JsonRpcParamsStruct = union([record(string(), JsonStruct), array(JsonStruct)]);\nvar JsonRpcRequestStruct = object2({\n  id: JsonRpcIdStruct,\n  jsonrpc: JsonRpcVersionStruct,\n  method: string(),\n  params: exactOptional(JsonRpcParamsStruct)\n});\nvar JsonRpcNotificationStruct = object2({\n  jsonrpc: JsonRpcVersionStruct,\n  method: string(),\n  params: exactOptional(JsonRpcParamsStruct)\n});\nvar PendingJsonRpcResponseStruct = object({\n  id: JsonRpcIdStruct,\n  jsonrpc: JsonRpcVersionStruct,\n  result: optional(unknown()),\n  error: optional(JsonRpcErrorStruct)\n});\nvar JsonRpcSuccessStruct = object2({\n  id: JsonRpcIdStruct,\n  jsonrpc: JsonRpcVersionStruct,\n  result: JsonStruct\n});\nvar JsonRpcFailureStruct = object2({\n  id: JsonRpcIdStruct,\n  jsonrpc: JsonRpcVersionStruct,\n  error: JsonRpcErrorStruct\n});\nvar JsonRpcResponseStruct = union([\n  JsonRpcSuccessStruct,\n  JsonRpcFailureStruct\n]);\nfunction isJsonRpcError(value) {\n  return is(value, JsonRpcErrorStruct);\n}\n\n// node_modules/@metamask/rpc-errors/dist/classes.mjs\nvar import_fast_safe_stringify = __toESM(require_fast_safe_stringify(), 1);\n\n// node_modules/@metamask/rpc-errors/dist/error-constants.mjs\nvar errorCodes = {\n  rpc: {\n    invalidInput: -32000,\n    resourceNotFound: -32001,\n    resourceUnavailable: -32002,\n    transactionRejected: -32003,\n    methodNotSupported: -32004,\n    limitExceeded: -32005,\n    parse: -32700,\n    invalidRequest: -32600,\n    methodNotFound: -32601,\n    invalidParams: -32602,\n    internal: -32603\n  },\n  provider: {\n    userRejectedRequest: 4001,\n    unauthorized: 4100,\n    unsupportedMethod: 4200,\n    disconnected: 4900,\n    chainDisconnected: 4901\n  }\n};\nvar errorValues = {\n  \"-32700\": {\n    standard: \"JSON RPC 2.0\",\n    message: \"Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.\"\n  },\n  \"-32600\": {\n    standard: \"JSON RPC 2.0\",\n    message: \"The JSON sent is not a valid Request object.\"\n  },\n  \"-32601\": {\n    standard: \"JSON RPC 2.0\",\n    message: \"The method does not exist / is not available.\"\n  },\n  \"-32602\": {\n    standard: \"JSON RPC 2.0\",\n    message: \"Invalid method parameter(s).\"\n  },\n  \"-32603\": {\n    standard: \"JSON RPC 2.0\",\n    message: \"Internal JSON-RPC error.\"\n  },\n  \"-32000\": {\n    standard: \"EIP-1474\",\n    message: \"Invalid input.\"\n  },\n  \"-32001\": {\n    standard: \"EIP-1474\",\n    message: \"Resource not found.\"\n  },\n  \"-32002\": {\n    standard: \"EIP-1474\",\n    message: \"Resource unavailable.\"\n  },\n  \"-32003\": {\n    standard: \"EIP-1474\",\n    message: \"Transaction rejected.\"\n  },\n  \"-32004\": {\n    standard: \"EIP-1474\",\n    message: \"Method not supported.\"\n  },\n  \"-32005\": {\n    standard: \"EIP-1474\",\n    message: \"Request limit exceeded.\"\n  },\n  \"4001\": {\n    standard: \"EIP-1193\",\n    message: \"User rejected the request.\"\n  },\n  \"4100\": {\n    standard: \"EIP-1193\",\n    message: \"The requested account and/or method has not been authorized by the user.\"\n  },\n  \"4200\": {\n    standard: \"EIP-1193\",\n    message: \"The requested method is not supported by this Ethereum provider.\"\n  },\n  \"4900\": {\n    standard: \"EIP-1193\",\n    message: \"The provider is disconnected from all chains.\"\n  },\n  \"4901\": {\n    standard: \"EIP-1193\",\n    message: \"The provider is disconnected from the specified chain.\"\n  }\n};\n\n// node_modules/@metamask/rpc-errors/dist/utils.mjs\nvar FALLBACK_ERROR_CODE = errorCodes.rpc.internal;\nvar FALLBACK_MESSAGE = \"Unspecified error message. This is a bug, please report it.\";\nvar FALLBACK_ERROR = {\n  code: FALLBACK_ERROR_CODE,\n  message: getMessageFromCode(FALLBACK_ERROR_CODE)\n};\nvar JSON_RPC_SERVER_ERROR_MESSAGE = \"Unspecified server error.\";\nfunction getMessageFromCode(code, fallbackMessage = FALLBACK_MESSAGE) {\n  if (isValidCode(code)) {\n    const codeString = code.toString();\n    if (hasProperty(errorValues, codeString)) {\n      return errorValues[codeString].message;\n    }\n    if (isJsonRpcServerError(code)) {\n      return JSON_RPC_SERVER_ERROR_MESSAGE;\n    }\n  }\n  return fallbackMessage;\n}\nfunction isValidCode(code) {\n  return Number.isInteger(code);\n}\nfunction serializeError(error, { fallbackError = FALLBACK_ERROR, shouldIncludeStack = true, shouldPreserveMessage = true } = {}) {\n  if (!isJsonRpcError(fallbackError)) {\n    throw new Error(\"Must provide fallback error with integer number code and string message.\");\n  }\n  const serialized = buildError(error, fallbackError, shouldPreserveMessage);\n  if (!shouldIncludeStack) {\n    delete serialized.stack;\n  }\n  return serialized;\n}\nfunction buildError(error, fallbackError, shouldPreserveMessage) {\n  if (error && typeof error === \"object\" && \"serialize\" in error && typeof error.serialize === \"function\") {\n    return error.serialize();\n  }\n  if (isJsonRpcError(error)) {\n    return error;\n  }\n  const originalMessage = getOriginalMessage(error);\n  const cause = serializeCause(error);\n  const fallbackWithCause = {\n    ...fallbackError,\n    ...shouldPreserveMessage && originalMessage && { message: originalMessage },\n    data: { cause }\n  };\n  return fallbackWithCause;\n}\nfunction getOriginalMessage(error) {\n  if (isObject2(error) && hasProperty(error, \"message\") && typeof error.message === \"string\" && error.message.length > 0) {\n    return error.message;\n  }\n  return;\n}\nfunction isJsonRpcServerError(code) {\n  return code >= -32099 && code <= -32000;\n}\nfunction serializeCause(error) {\n  if (Array.isArray(error)) {\n    return error.map((entry) => {\n      if (isValidJson(entry)) {\n        return entry;\n      } else if (isObject2(entry)) {\n        return serializeObject(entry);\n      }\n      return null;\n    });\n  } else if (isObject2(error)) {\n    return serializeObject(error);\n  }\n  if (isValidJson(error)) {\n    return error;\n  }\n  return null;\n}\nfunction serializeObject(object3) {\n  return Object.getOwnPropertyNames(object3).reduce((acc, key) => {\n    const value = object3[key];\n    if (isValidJson(value)) {\n      acc[key] = value;\n    }\n    return acc;\n  }, {});\n}\nfunction dataHasCause(data) {\n  return isObject2(data) && hasProperty(data, \"cause\") && isObject2(data.cause);\n}\n\n// node_modules/@metamask/rpc-errors/dist/classes.mjs\nfunction $importDefault(module) {\n  if (module?.__esModule) {\n    return module.default;\n  }\n  return module;\n}\nvar safeStringify = $importDefault(import_fast_safe_stringify.default);\n\nclass JsonRpcError extends Error {\n  constructor(code, message, data) {\n    if (!Number.isInteger(code)) {\n      throw new Error('\"code\" must be an integer.');\n    }\n    if (!message || typeof message !== \"string\") {\n      throw new Error('\"message\" must be a non-empty string.');\n    }\n    if (dataHasCause(data)) {\n      super(message, { cause: data.cause });\n      if (!hasProperty(this, \"cause\")) {\n        Object.assign(this, { cause: data.cause });\n      }\n    } else {\n      super(message);\n    }\n    if (data !== undefined) {\n      this.data = data;\n    }\n    this.code = code;\n  }\n  serialize() {\n    const serialized = {\n      code: this.code,\n      message: this.message\n    };\n    if (this.data !== undefined) {\n      serialized.data = this.data;\n      if (isPlainObject(this.data)) {\n        serialized.data.cause = serializeCause(this.data.cause);\n      }\n    }\n    if (this.stack) {\n      serialized.stack = this.stack;\n    }\n    return serialized;\n  }\n  toString() {\n    return safeStringify(this.serialize(), stringifyReplacer, 2);\n  }\n}\n\nclass EthereumProviderError extends JsonRpcError {\n  constructor(code, message, data) {\n    if (!isValidEthProviderCode(code)) {\n      throw new Error('\"code\" must be an integer such that: 1000 <= code <= 4999');\n    }\n    super(code, message, data);\n  }\n}\nfunction isValidEthProviderCode(code) {\n  return Number.isInteger(code) && code >= 1000 && code <= 4999;\n}\nfunction stringifyReplacer(_, value) {\n  if (value === \"[Circular]\") {\n    return;\n  }\n  return value;\n}\n// node_modules/@metamask/rpc-errors/dist/errors.mjs\nvar rpcErrors = {\n  parse: (arg) => getJsonRpcError(errorCodes.rpc.parse, arg),\n  invalidRequest: (arg) => getJsonRpcError(errorCodes.rpc.invalidRequest, arg),\n  invalidParams: (arg) => getJsonRpcError(errorCodes.rpc.invalidParams, arg),\n  methodNotFound: (arg) => getJsonRpcError(errorCodes.rpc.methodNotFound, arg),\n  internal: (arg) => getJsonRpcError(errorCodes.rpc.internal, arg),\n  server: (opts) => {\n    if (!opts || typeof opts !== \"object\" || Array.isArray(opts)) {\n      throw new Error(\"Ethereum RPC Server errors must provide single object argument.\");\n    }\n    const { code } = opts;\n    if (!Number.isInteger(code) || code > -32005 || code < -32099) {\n      throw new Error('\"code\" must be an integer such that: -32099 <= code <= -32005');\n    }\n    return getJsonRpcError(code, opts);\n  },\n  invalidInput: (arg) => getJsonRpcError(errorCodes.rpc.invalidInput, arg),\n  resourceNotFound: (arg) => getJsonRpcError(errorCodes.rpc.resourceNotFound, arg),\n  resourceUnavailable: (arg) => getJsonRpcError(errorCodes.rpc.resourceUnavailable, arg),\n  transactionRejected: (arg) => getJsonRpcError(errorCodes.rpc.transactionRejected, arg),\n  methodNotSupported: (arg) => getJsonRpcError(errorCodes.rpc.methodNotSupported, arg),\n  limitExceeded: (arg) => getJsonRpcError(errorCodes.rpc.limitExceeded, arg)\n};\nvar providerErrors = {\n  userRejectedRequest: (arg) => {\n    return getEthProviderError(errorCodes.provider.userRejectedRequest, arg);\n  },\n  unauthorized: (arg) => {\n    return getEthProviderError(errorCodes.provider.unauthorized, arg);\n  },\n  unsupportedMethod: (arg) => {\n    return getEthProviderError(errorCodes.provider.unsupportedMethod, arg);\n  },\n  disconnected: (arg) => {\n    return getEthProviderError(errorCodes.provider.disconnected, arg);\n  },\n  chainDisconnected: (arg) => {\n    return getEthProviderError(errorCodes.provider.chainDisconnected, arg);\n  },\n  custom: (opts) => {\n    if (!opts || typeof opts !== \"object\" || Array.isArray(opts)) {\n      throw new Error(\"Ethereum Provider custom errors must provide single object argument.\");\n    }\n    const { code, message, data } = opts;\n    if (!message || typeof message !== \"string\") {\n      throw new Error('\"message\" must be a nonempty string');\n    }\n    return new EthereumProviderError(code, message, data);\n  }\n};\nfunction getJsonRpcError(code, arg) {\n  const [message, data] = parseOpts(arg);\n  return new JsonRpcError(code, message ?? getMessageFromCode(code), data);\n}\nfunction getEthProviderError(code, arg) {\n  const [message, data] = parseOpts(arg);\n  return new EthereumProviderError(code, message ?? getMessageFromCode(code), data);\n}\nfunction parseOpts(arg) {\n  if (arg) {\n    if (typeof arg === \"string\") {\n      return [arg];\n    } else if (typeof arg === \"object\" && !Array.isArray(arg)) {\n      const { message, data } = arg;\n      if (message && typeof message !== \"string\") {\n        throw new Error(\"Must specify string message.\");\n      }\n      return [message ?? undefined, data];\n    }\n  }\n  return [];\n}\n// node_modules/eventemitter3/index.mjs\nvar import__ = __toESM(require_eventemitter3(), 1);\n\n// src/types.ts\nvar GeminiSdkEvent;\n((GeminiSdkEvent2) => {\n  GeminiSdkEvent2[\"POPUP_LOADED\"] = \"POPUP_LOADED\";\n  GeminiSdkEvent2[\"POPUP_UNLOADED\"] = \"POPUP_UNLOADED\";\n  GeminiSdkEvent2[\"POPUP_APP_CONTEXT\"] = \"POPUP_APP_CONTEXT\";\n  GeminiSdkEvent2[\"SDK_CONNECT\"] = \"SDK_CONNECT\";\n  GeminiSdkEvent2[\"SDK_DISCONNECT\"] = \"SDK_DISCONNECT\";\n  GeminiSdkEvent2[\"SDK_SEND_TRANSACTION\"] = \"SDK_SEND_TRANSACTION\";\n  GeminiSdkEvent2[\"SDK_SIGN_DATA\"] = \"SDK_SIGN_DATA\";\n  GeminiSdkEvent2[\"SDK_SIGN_TYPED_DATA\"] = \"SDK_SIGN_TYPED_DATA\";\n  GeminiSdkEvent2[\"SDK_SWITCH_CHAIN\"] = \"SDK_SWITCH_CHAIN\";\n  GeminiSdkEvent2[\"SDK_OPEN_SETTINGS\"] = \"SDK_OPEN_SETTINGS\";\n})(GeminiSdkEvent ||= {});\nclass ProviderEventEmitter extends import__.default {\n}\n\n// src/utils/base64.ts\nfunction encodeBase64(array2) {\n  let base64;\n  if (typeof Buffer !== \"undefined\") {\n    base64 = Buffer.from(array2).toString(\"base64\");\n  } else {\n    base64 = btoa(Array.from(array2).map((b) => String.fromCharCode(b)).join(\"\"));\n  }\n  return base64.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n}\nfunction decodeBase64(base64url) {\n  let base64 = base64url.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  while (base64.length % 4 !== 0) {\n    base64 += \"=\";\n  }\n  if (typeof Buffer !== \"undefined\") {\n    return new Uint8Array(Buffer.from(base64, \"base64\"));\n  }\n  const binaryString = atob(base64);\n  const bytes = new Uint8Array(binaryString.length);\n  for (let i = 0;i < binaryString.length; i++) {\n    bytes[i] = binaryString.charCodeAt(i);\n  }\n  return bytes;\n}\nfunction bufferToBase64URLString(buffer) {\n  const bytes = buffer instanceof Uint8Array ? buffer : new Uint8Array(buffer);\n  return encodeBase64(bytes);\n}\nfunction utf8StringToBuffer(value) {\n  if (typeof TextEncoder !== \"undefined\") {\n    return new TextEncoder().encode(value);\n  }\n  if (typeof Buffer !== \"undefined\") {\n    return new Uint8Array(Buffer.from(value, \"utf8\"));\n  }\n  const bytes = new Uint8Array(value.length);\n  for (let i = 0;i < value.length; i++) {\n    bytes[i] = value.charCodeAt(i);\n  }\n  return bytes;\n}\nfunction base64ToHex(base64) {\n  const bytes = decodeBase64(base64);\n  return Array.from(bytes).map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n}\n// src/constants.ts\nvar SDK_BACKEND_URL = \"https://keys.gemini.com\";\nvar SDK_VERSION = \"0.1.0\";\nvar DEFAULT_CHAIN_ID = 42161;\nvar MAINNET_CHAIN_IDS = {\n  ETHEREUM: 1,\n  ARBITRUM_ONE: 42161,\n  OP_MAINNET: 10,\n  BASE: 8453,\n  POLYGON: 137\n};\nvar TESTNET_CHAIN_IDS = {\n  SEPOLIA: 11155111,\n  ARBITRUM_SEPOLIA: 421614,\n  OP_SEPOLIA: 11155420,\n  BASE_SEPOLIA: 84532,\n  POLYGON_AMOY: 80002\n};\nvar SUPPORTED_CHAIN_IDS = [\n  ...Object.values(MAINNET_CHAIN_IDS),\n  ...Object.values(TESTNET_CHAIN_IDS)\n];\nvar POPUP_WIDTH = 420;\nvar POPUP_HEIGHT = 650;\n\n// src/utils/popup.ts\nvar openPopup = (url) => {\n  const left = (window.innerWidth - POPUP_WIDTH) / 2 + window.screenX;\n  const top = (window.innerHeight - POPUP_HEIGHT) / 2 + window.screenY;\n  const popupId = `gemini_wallet_${crypto.randomUUID()}`;\n  const popup = window.open(url, popupId, `width=${POPUP_WIDTH}, height=${POPUP_HEIGHT}, left=${left}, top=${top}`);\n  popup?.focus();\n  if (!popup) {\n    throw rpcErrors.internal(\"Pop up window failed to open\");\n  }\n  return popup;\n};\nvar closePopup = (popup) => {\n  if (popup && !popup.closed) {\n    popup.close();\n  }\n};\n// src/utils/strings.ts\nvar hexStringFromNumber = (num) => `0x${BigInt(num).toString(16)}`;\nvar safeJsonStringify = (obj) => JSON.stringify(obj, (_, value) => typeof value === \"bigint\" ? value.toString() + \"n\" : value, 2);\n\n// src/utils/index.ts\nvar generateRequestId = () => crypto.randomUUID();\n\n// src/communicator.ts\nclass Communicator {\n  appMetadata;\n  url;\n  popup = null;\n  listeners = new Map;\n  onDisconnectCallback;\n  constructor({ appMetadata, onDisconnectCallback }) {\n    this.url = new URL(SDK_BACKEND_URL);\n    this.appMetadata = appMetadata;\n    this.onDisconnectCallback = onDisconnectCallback;\n  }\n  async postMessage(message) {\n    const popup = await this.waitForPopupLoaded();\n    popup.postMessage(message, this.url.origin);\n  }\n  async postRequestAndWaitForResponse(request) {\n    const responsePromise = this.onMessage(({ requestId }) => requestId === request.requestId);\n    await this.postMessage(request);\n    return responsePromise;\n  }\n  async onMessage(predicate) {\n    return new Promise((resolve, reject) => {\n      const listener = (event) => {\n        if (event.origin !== this.url.origin)\n          return;\n        const message = event.data;\n        if (predicate(message)) {\n          resolve(message);\n          window.removeEventListener(\"message\", listener);\n          this.listeners.delete(listener);\n        }\n      };\n      window.addEventListener(\"message\", listener);\n      this.listeners.set(listener, { reject });\n    });\n  }\n  onRequestCancelled() {\n    closePopup(this.popup ?? undefined);\n    this.popup = null;\n    this.listeners.forEach(({ reject }, listener) => {\n      reject(providerErrors.userRejectedRequest());\n      window.removeEventListener(\"message\", listener);\n    });\n    this.listeners.clear();\n  }\n  async waitForPopupLoaded() {\n    if (this.popup && !this.popup.closed) {\n      this.popup.focus();\n      return this.popup;\n    }\n    this.popup = openPopup(this.url);\n    this.onMessage(({ event }) => event === \"POPUP_UNLOADED\" /* POPUP_UNLOADED */).then(() => this.onRequestCancelled()).catch(() => {});\n    this.onMessage(({ event }) => event === \"SDK_DISCONNECT\" /* SDK_DISCONNECT */).then(() => {\n      this.onDisconnectCallback?.();\n      this.onRequestCancelled();\n    }).catch(() => {});\n    return this.onMessage(({ event }) => event === \"POPUP_LOADED\" /* POPUP_LOADED */).then((message) => {\n      this.postMessage({\n        chainId: DEFAULT_CHAIN_ID,\n        data: {\n          appMetadata: this.appMetadata,\n          origin: window.location.origin,\n          sdkVersion: SDK_VERSION\n        },\n        event: \"POPUP_APP_CONTEXT\" /* POPUP_APP_CONTEXT */,\n        origin: window.location.origin,\n        requestId: message.requestId\n      });\n      return message;\n    }).then(() => {\n      if (!this.popup)\n        throw rpcErrors.internal();\n      return this.popup;\n    });\n  }\n}\n// src/storage/storageInterface.ts\nvar STORAGE_ETH_ACCOUNTS_KEY = \"eth-accounts\";\nvar STORAGE_ETH_ACTIVE_CHAIN_KEY = \"eth-active-chain\";\nvar STORAGE_PASSKEY_CREDENTIAL_KEY = \"passkey-credential\";\nvar STORAGE_SMART_ACCOUNT_KEY = \"smart-account\";\nvar STORAGE_SETTINGS_KEY = \"settings\";\n\n// src/storage/storage.ts\nvar memoryStorage = {};\nclass GeminiStorage {\n  scope = \"@gemini\";\n  module = \"wallet\";\n  scopedKey(key) {\n    return `${this.scope}.${this.module}.${key}`;\n  }\n  async storeObject(key, item) {\n    const json = safeJsonStringify(item);\n    await this.setItem(key, json);\n  }\n  async loadObject(key, fallback) {\n    const item = await this.getItem(key);\n    if (!item) {\n      await this.storeObject(key, fallback);\n      return fallback;\n    }\n    try {\n      return JSON.parse(item);\n    } catch (error) {\n      console.error(`Error parsing JSON for key ${key}:`, error);\n      return fallback;\n    }\n  }\n  setItem(key, value) {\n    const scoped = this.scopedKey(key);\n    try {\n      localStorage.setItem(scoped, value);\n    } catch {\n      memoryStorage[scoped] = value;\n    }\n    return Promise.resolve();\n  }\n  getItem(key) {\n    const scoped = this.scopedKey(key);\n    try {\n      return Promise.resolve(localStorage.getItem(scoped) ?? undefined);\n    } catch {\n      return Promise.resolve(memoryStorage[scoped] || undefined);\n    }\n  }\n  removeItem(key) {\n    const scoped = this.scopedKey(key);\n    try {\n      localStorage.removeItem(scoped);\n    } catch {\n      delete memoryStorage[scoped];\n    }\n    return Promise.resolve();\n  }\n}\n// src/wallets/wallet.ts\nfunction isChainSupportedByGeminiSw(chainId) {\n  return SUPPORTED_CHAIN_IDS.includes(chainId);\n}\n\nclass GeminiWallet {\n  communicator;\n  storage;\n  initPromise;\n  accounts = [];\n  chain = { id: DEFAULT_CHAIN_ID };\n  constructor({\n    appMetadata,\n    chain,\n    onDisconnectCallback,\n    storage\n  }) {\n    this.communicator = new Communicator({\n      appMetadata,\n      onDisconnectCallback\n    });\n    this.storage = storage || new GeminiStorage;\n    this.initPromise = this.initializeFromStorage(chain?.id ?? this.chain.id);\n  }\n  async initializeFromStorage(defaultChainId) {\n    const [storedChain, storedAccounts] = await Promise.all([\n      this.storage.loadObject(STORAGE_ETH_ACTIVE_CHAIN_KEY, {\n        id: defaultChainId\n      }),\n      this.storage.loadObject(STORAGE_ETH_ACCOUNTS_KEY, this.accounts)\n    ]);\n    this.chain = storedChain;\n    this.accounts = storedAccounts;\n  }\n  async ensureInitialized() {\n    await this.initPromise;\n  }\n  async connect() {\n    await this.ensureInitialized();\n    const response = await this.sendMessageToPopup({\n      chainId: this.chain.id,\n      event: \"SDK_CONNECT\" /* SDK_CONNECT */,\n      origin: window.location.origin\n    });\n    this.accounts = [response.data.address];\n    await this.storage.storeObject(STORAGE_ETH_ACCOUNTS_KEY, this.accounts);\n    return this.accounts;\n  }\n  async switchChain({\n    id\n  }) {\n    await this.ensureInitialized();\n    if (isChainSupportedByGeminiSw(id)) {\n      this.chain = { id };\n      await this.storage.storeObject(STORAGE_ETH_ACTIVE_CHAIN_KEY, { id });\n      return;\n    }\n    const response = await this.sendMessageToPopup({\n      chainId: this.chain.id,\n      data: id,\n      event: \"SDK_SWITCH_CHAIN\" /* SDK_SWITCH_CHAIN */,\n      origin: window.location.origin\n    });\n    return response.data.error;\n  }\n  async sendTransaction(txData) {\n    await this.ensureInitialized();\n    const response = await this.sendMessageToPopup({\n      chainId: this.chain.id,\n      data: txData,\n      event: \"SDK_SEND_TRANSACTION\" /* SDK_SEND_TRANSACTION */,\n      origin: window.location.origin\n    });\n    return response.data;\n  }\n  async signData({\n    message\n  }) {\n    await this.ensureInitialized();\n    const response = await this.sendMessageToPopup({\n      chainId: this.chain.id,\n      data: { message },\n      event: \"SDK_SIGN_DATA\" /* SDK_SIGN_DATA */,\n      origin: window.location.origin\n    });\n    return response.data;\n  }\n  async signTypedData({\n    message,\n    types,\n    primaryType,\n    domain\n  }) {\n    await this.ensureInitialized();\n    const response = await this.sendMessageToPopup({\n      chainId: this.chain.id,\n      data: {\n        domain,\n        message,\n        primaryType,\n        types\n      },\n      event: \"SDK_SIGN_TYPED_DATA\" /* SDK_SIGN_TYPED_DATA */,\n      origin: window.location.origin\n    });\n    return response.data;\n  }\n  async openSettings() {\n    await this.ensureInitialized();\n    await this.sendMessageToPopup({\n      chainId: this.chain.id,\n      data: {},\n      event: \"SDK_OPEN_SETTINGS\" /* SDK_OPEN_SETTINGS */,\n      origin: window.location.origin\n    });\n  }\n  sendMessageToPopup(request) {\n    return this.communicator.postRequestAndWaitForResponse({\n      ...request,\n      requestId: window?.crypto?.randomUUID()\n    });\n  }\n}\n// src/provider/provider.utils.ts\nvar fetchRpcRequest = async (request, rpcUrl) => {\n  const requestBody = {\n    ...request,\n    id: window?.crypto?.randomUUID(),\n    jsonrpc: \"2.0\"\n  };\n  const res = await window.fetch(rpcUrl, {\n    body: JSON.stringify(requestBody),\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    method: \"POST\",\n    mode: \"cors\"\n  });\n  const { result, error } = await res.json();\n  if (error) {\n    throw error;\n  }\n  return result;\n};\nfunction validateRpcRequestArgs(args) {\n  if (!args || typeof args !== \"object\" || Array.isArray(args)) {\n    throw rpcErrors.invalidParams({\n      message: \"Expected a single, non-array, object argument.\"\n    });\n  }\n  const { method, params } = args;\n  if (typeof method !== \"string\" || method.length === 0) {\n    throw rpcErrors.invalidParams({\n      message: \"'args.method' must be a non-empty string.\"\n    });\n  }\n  if (params !== undefined && !Array.isArray(params) && (typeof params !== \"object\" || params === null)) {\n    throw rpcErrors.invalidParams({\n      message: \"'args.params' must be an object or array if provided.\"\n    });\n  }\n}\nfunction convertSendValuesToBigInt(tx) {\n  const FIELDS_TO_NORMALIZE = [\"value\", \"gas\", \"gasPrice\", \"maxPriorityFeePerGas\", \"maxFeePerGas\"];\n  const normalized = { ...tx };\n  for (const field of FIELDS_TO_NORMALIZE) {\n    if (!(field in tx)) {\n      continue;\n    }\n    const value = tx[field];\n    if (typeof value === \"bigint\") {\n      continue;\n    }\n    if (isHex(value)) {\n      normalized[field] = BigInt(value);\n    }\n  }\n  return normalized;\n}\n\n// src/provider/provider.ts\nclass GeminiWalletProvider extends ProviderEventEmitter {\n  config;\n  wallet = undefined;\n  constructor(providerConfig) {\n    super();\n    this.config = providerConfig;\n    this.wallet = new GeminiWallet({\n      ...providerConfig,\n      onDisconnectCallback: this.disconnect.bind(this)\n    });\n  }\n  async request(args) {\n    try {\n      validateRpcRequestArgs(args);\n      if (!this.wallet?.accounts?.length) {\n        switch (args.method) {\n          case \"eth_requestAccounts\": {\n            this.wallet = new GeminiWallet({\n              ...this.config,\n              onDisconnectCallback: this.disconnect.bind(this)\n            });\n            await this.wallet.connect();\n            this.emit(\"accountsChanged\", this.wallet.accounts);\n            break;\n          }\n          case \"net_version\":\n            return DEFAULT_CHAIN_ID;\n          case \"eth_chainId\":\n            return hexStringFromNumber(DEFAULT_CHAIN_ID);\n          default: {\n            throw providerErrors.unauthorized();\n          }\n        }\n      }\n      let response;\n      let requestParams;\n      switch (args.method) {\n        case \"eth_requestAccounts\":\n        case \"eth_accounts\":\n          response = this.wallet.accounts;\n          break;\n        case \"net_version\":\n          response = this.wallet.chain.id;\n          break;\n        case \"eth_chainId\":\n          response = hexStringFromNumber(this.wallet.chain.id);\n          break;\n        case \"personal_sign\":\n        case \"wallet_sign\":\n          requestParams = args.params;\n          response = await this.wallet.signData({\n            account: requestParams[1],\n            message: requestParams[0]\n          });\n          if (response.error) {\n            throw rpcErrors.transactionRejected(response.error);\n          } else {\n            response = response.hash;\n          }\n          break;\n        case \"eth_sendTransaction\":\n        case \"wallet_sendTransaction\":\n          requestParams = args.params;\n          requestParams = convertSendValuesToBigInt(requestParams[0]);\n          response = await this.wallet.sendTransaction(requestParams);\n          if (response.error) {\n            throw rpcErrors.transactionRejected(response.error);\n          } else {\n            response = response.hash;\n          }\n          break;\n        case \"wallet_switchEthereumChain\": {\n          const rawParams = args.params;\n          let chainId;\n          if (Array.isArray(rawParams) && rawParams[0]?.chainId) {\n            chainId = parseInt(rawParams[0].chainId, 16);\n          } else if (rawParams && typeof rawParams === \"object\" && \"id\" in rawParams && Number.isInteger(rawParams.id)) {\n            chainId = rawParams.id;\n          } else {\n            throw rpcErrors.invalidParams(\"Invalid chain id argument. Expected [{ chainId: hex_string }] or { id: number }.\");\n          }\n          response = await this.wallet.switchChain({ id: chainId });\n          if (response) {\n            throw providerErrors.custom({ code: 4902, message: response });\n          }\n          await this.emit(\"chainChanged\", hexStringFromNumber(chainId));\n          break;\n        }\n        case \"eth_signTypedData_v1\":\n        case \"eth_signTypedData_v2\":\n        case \"eth_signTypedData_v3\":\n        case \"eth_signTypedData_v4\":\n        case \"eth_signTypedData\": {\n          requestParams = args.params;\n          const signedTypedDataParams = JSON.parse(requestParams[1]);\n          response = await this.wallet.signTypedData({\n            account: requestParams[0],\n            domain: signedTypedDataParams.domain,\n            message: signedTypedDataParams.message,\n            primaryType: signedTypedDataParams.primaryType,\n            types: signedTypedDataParams.types\n          });\n          if (response.error) {\n            throw rpcErrors.transactionRejected(response.error);\n          } else {\n            response = response.hash;\n          }\n          break;\n        }\n        case \"eth_ecRecover\":\n        case \"eth_subscribe\":\n        case \"eth_unsubscribe\":\n        case \"personal_ecRecover\":\n        case \"eth_signTransaction\":\n        case \"wallet_watchAsset\":\n        case \"wallet_sendCalls\":\n        case \"wallet_getCallsStatus\":\n        case \"wallet_getCapabilities\":\n        case \"wallet_showCallsStatus\":\n        case \"wallet_grantPermissions\":\n          throw rpcErrors.methodNotSupported(\"Not yet implemented.\");\n        case \"eth_sign\":\n        case \"eth_coinbase\":\n        case \"wallet_addEthereumChain\":\n          throw rpcErrors.methodNotSupported();\n        default:\n          if (!this.wallet.chain.rpcUrl) {\n            throw rpcErrors.internal(`RPC URL missing for current chain (${this.wallet.chain.id})`);\n          }\n          return fetchRpcRequest(args, this.wallet.chain.rpcUrl);\n      }\n      return response;\n    } catch (error) {\n      const { code } = error;\n      if (code === errorCodes.provider.unauthorized) {\n        this.disconnect();\n      }\n      return Promise.reject(serializeError(error));\n    }\n  }\n  async openSettings() {\n    await this.wallet?.openSettings();\n  }\n  async disconnect() {\n    this.wallet = undefined;\n    const Storage = new GeminiStorage;\n    await Storage.removeItem(STORAGE_ETH_ACCOUNTS_KEY);\n    await Storage.removeItem(STORAGE_ETH_ACTIVE_CHAIN_KEY);\n    await this.emit(\"disconnect\", \"User initiated disconnection\");\n  }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdlbWluaS13YWxsZXQvY29yZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0YsOEJBQThCO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLHdEQUF3RCxhQUFhOztBQUVyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGdCQUFnQjtBQUMzRDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNI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QSwwQ0FBMEMsK0JBQStCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxxQkFBcUI7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUErQkUiLCJzb3VyY2VzIjpbIi9Vc2Vycy91bmRldnkvcG9ydGZvbGlvLXByb2plY3Qvbm9kZV9tb2R1bGVzL0BnZW1pbmktd2FsbGV0L2NvcmUvZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fdG9FU00gPSAobW9kLCBpc05vZGVNb2RlLCB0YXJnZXQpID0+IHtcbiAgdGFyZ2V0ID0gbW9kICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kKSkgOiB7fTtcbiAgY29uc3QgdG8gPSBpc05vZGVNb2RlIHx8ICFtb2QgfHwgIW1vZC5fX2VzTW9kdWxlID8gX19kZWZQcm9wKHRhcmdldCwgXCJkZWZhdWx0XCIsIHsgdmFsdWU6IG1vZCwgZW51bWVyYWJsZTogdHJ1ZSB9KSA6IHRhcmdldDtcbiAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKG1vZCkpXG4gICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSlcbiAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7XG4gICAgICAgIGdldDogKCkgPT4gbW9kW2tleV0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgIH0pO1xuICByZXR1cm4gdG87XG59O1xudmFyIF9fY29tbW9uSlMgPSAoY2IsIG1vZCkgPT4gKCkgPT4gKG1vZCB8fCBjYigobW9kID0geyBleHBvcnRzOiB7fSB9KS5leHBvcnRzLCBtb2QpLCBtb2QuZXhwb3J0cyk7XG5cbi8vIG5vZGVfbW9kdWxlcy9mYXN0LXNhZmUtc3RyaW5naWZ5L2luZGV4LmpzXG52YXIgcmVxdWlyZV9mYXN0X3NhZmVfc3RyaW5naWZ5ID0gX19jb21tb25KUygoZXhwb3J0cywgbW9kdWxlKSA9PiB7XG4gIG1vZHVsZS5leHBvcnRzID0gc3RyaW5naWZ5O1xuICBzdHJpbmdpZnkuZGVmYXVsdCA9IHN0cmluZ2lmeTtcbiAgc3RyaW5naWZ5LnN0YWJsZSA9IGRldGVybWluaXN0aWNTdHJpbmdpZnk7XG4gIHN0cmluZ2lmeS5zdGFibGVTdHJpbmdpZnkgPSBkZXRlcm1pbmlzdGljU3RyaW5naWZ5O1xuICB2YXIgTElNSVRfUkVQTEFDRV9OT0RFID0gXCJbLi4uXVwiO1xuICB2YXIgQ0lSQ1VMQVJfUkVQTEFDRV9OT0RFID0gXCJbQ2lyY3VsYXJdXCI7XG4gIHZhciBhcnIgPSBbXTtcbiAgdmFyIHJlcGxhY2VyU3RhY2sgPSBbXTtcbiAgZnVuY3Rpb24gZGVmYXVsdE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRlcHRoTGltaXQ6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFxuICAgICAgZWRnZXNMaW1pdDogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHN0cmluZ2lmeShvYmosIHJlcGxhY2VyLCBzcGFjZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucygpO1xuICAgIH1cbiAgICBkZWNpcmMob2JqLCBcIlwiLCAwLCBbXSwgdW5kZWZpbmVkLCAwLCBvcHRpb25zKTtcbiAgICB2YXIgcmVzO1xuICAgIHRyeSB7XG4gICAgICBpZiAocmVwbGFjZXJTdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmVzID0gSlNPTi5zdHJpbmdpZnkob2JqLCByZXBsYWNlciwgc3BhY2VyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcyA9IEpTT04uc3RyaW5naWZ5KG9iaiwgcmVwbGFjZUdldHRlclZhbHVlcyhyZXBsYWNlciksIHNwYWNlcik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KFwiW3VuYWJsZSB0byBzZXJpYWxpemUsIGNpcmN1bGFyIHJlZmVyZW5jZSBpcyB0b28gY29tcGxleCB0byBhbmFseXplXVwiKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgd2hpbGUgKGFyci5sZW5ndGggIT09IDApIHtcbiAgICAgICAgdmFyIHBhcnQgPSBhcnIucG9wKCk7XG4gICAgICAgIGlmIChwYXJ0Lmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwYXJ0WzBdLCBwYXJ0WzFdLCBwYXJ0WzNdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJ0WzBdW3BhcnRbMV1dID0gcGFydFsyXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIGZ1bmN0aW9uIHNldFJlcGxhY2UocmVwbGFjZSwgdmFsLCBrLCBwYXJlbnQpIHtcbiAgICB2YXIgcHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwYXJlbnQsIGspO1xuICAgIGlmIChwcm9wZXJ0eURlc2NyaXB0b3IuZ2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChwcm9wZXJ0eURlc2NyaXB0b3IuY29uZmlndXJhYmxlKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwYXJlbnQsIGssIHsgdmFsdWU6IHJlcGxhY2UgfSk7XG4gICAgICAgIGFyci5wdXNoKFtwYXJlbnQsIGssIHZhbCwgcHJvcGVydHlEZXNjcmlwdG9yXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXBsYWNlclN0YWNrLnB1c2goW3ZhbCwgaywgcmVwbGFjZV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwYXJlbnRba10gPSByZXBsYWNlO1xuICAgICAgYXJyLnB1c2goW3BhcmVudCwgaywgdmFsXSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGRlY2lyYyh2YWwsIGssIGVkZ2VJbmRleCwgc3RhY2ssIHBhcmVudCwgZGVwdGgsIG9wdGlvbnMpIHtcbiAgICBkZXB0aCArPSAxO1xuICAgIHZhciBpO1xuICAgIGlmICh0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiICYmIHZhbCAhPT0gbnVsbCkge1xuICAgICAgZm9yIChpID0gMDtpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHN0YWNrW2ldID09PSB2YWwpIHtcbiAgICAgICAgICBzZXRSZXBsYWNlKENJUkNVTEFSX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlcHRoTGltaXQgIT09IFwidW5kZWZpbmVkXCIgJiYgZGVwdGggPiBvcHRpb25zLmRlcHRoTGltaXQpIHtcbiAgICAgICAgc2V0UmVwbGFjZShMSU1JVF9SRVBMQUNFX05PREUsIHZhbCwgaywgcGFyZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmVkZ2VzTGltaXQgIT09IFwidW5kZWZpbmVkXCIgJiYgZWRnZUluZGV4ICsgMSA+IG9wdGlvbnMuZWRnZXNMaW1pdCkge1xuICAgICAgICBzZXRSZXBsYWNlKExJTUlUX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzdGFjay5wdXNoKHZhbCk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIGZvciAoaSA9IDA7aSA8IHZhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGRlY2lyYyh2YWxbaV0sIGksIGksIHN0YWNrLCB2YWwsIGRlcHRoLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgICAgICBmb3IgKGkgPSAwO2kgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgZGVjaXJjKHZhbFtrZXldLCBrZXksIGksIHN0YWNrLCB2YWwsIGRlcHRoLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhY2sucG9wKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGNvbXBhcmVGdW5jdGlvbihhLCBiKSB7XG4gICAgaWYgKGEgPCBiKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGlmIChhID4gYikge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG4gIGZ1bmN0aW9uIGRldGVybWluaXN0aWNTdHJpbmdpZnkob2JqLCByZXBsYWNlciwgc3BhY2VyLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBvcHRpb25zID0gZGVmYXVsdE9wdGlvbnMoKTtcbiAgICB9XG4gICAgdmFyIHRtcCA9IGRldGVybWluaXN0aWNEZWNpcmMob2JqLCBcIlwiLCAwLCBbXSwgdW5kZWZpbmVkLCAwLCBvcHRpb25zKSB8fCBvYmo7XG4gICAgdmFyIHJlcztcbiAgICB0cnkge1xuICAgICAgaWYgKHJlcGxhY2VyU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJlcyA9IEpTT04uc3RyaW5naWZ5KHRtcCwgcmVwbGFjZXIsIHNwYWNlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXMgPSBKU09OLnN0cmluZ2lmeSh0bXAsIHJlcGxhY2VHZXR0ZXJWYWx1ZXMocmVwbGFjZXIpLCBzcGFjZXIpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShcIlt1bmFibGUgdG8gc2VyaWFsaXplLCBjaXJjdWxhciByZWZlcmVuY2UgaXMgdG9vIGNvbXBsZXggdG8gYW5hbHl6ZV1cIik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHdoaWxlIChhcnIubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gYXJyLnBvcCgpO1xuICAgICAgICBpZiAocGFydC5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGFydFswXSwgcGFydFsxXSwgcGFydFszXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFydFswXVtwYXJ0WzFdXSA9IHBhcnRbMl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICBmdW5jdGlvbiBkZXRlcm1pbmlzdGljRGVjaXJjKHZhbCwgaywgZWRnZUluZGV4LCBzdGFjaywgcGFyZW50LCBkZXB0aCwgb3B0aW9ucykge1xuICAgIGRlcHRoICs9IDE7XG4gICAgdmFyIGk7XG4gICAgaWYgKHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCIgJiYgdmFsICE9PSBudWxsKSB7XG4gICAgICBmb3IgKGkgPSAwO2kgPCBzdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc3RhY2tbaV0gPT09IHZhbCkge1xuICAgICAgICAgIHNldFJlcGxhY2UoQ0lSQ1VMQVJfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbC50b0pTT04gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVwdGhMaW1pdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkZXB0aCA+IG9wdGlvbnMuZGVwdGhMaW1pdCkge1xuICAgICAgICBzZXRSZXBsYWNlKExJTUlUX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZWRnZXNMaW1pdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBlZGdlSW5kZXggKyAxID4gb3B0aW9ucy5lZGdlc0xpbWl0KSB7XG4gICAgICAgIHNldFJlcGxhY2UoTElNSVRfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN0YWNrLnB1c2godmFsKTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgZm9yIChpID0gMDtpIDwgdmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZGV0ZXJtaW5pc3RpY0RlY2lyYyh2YWxbaV0sIGksIGksIHN0YWNrLCB2YWwsIGRlcHRoLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHRtcCA9IHt9O1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbCkuc29ydChjb21wYXJlRnVuY3Rpb24pO1xuICAgICAgICBmb3IgKGkgPSAwO2kgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgZGV0ZXJtaW5pc3RpY0RlY2lyYyh2YWxba2V5XSwga2V5LCBpLCBzdGFjaywgdmFsLCBkZXB0aCwgb3B0aW9ucyk7XG4gICAgICAgICAgdG1wW2tleV0gPSB2YWxba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBhcmVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIGFyci5wdXNoKFtwYXJlbnQsIGssIHZhbF0pO1xuICAgICAgICAgIHBhcmVudFtrXSA9IHRtcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdG1wO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGFjay5wb3AoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcmVwbGFjZUdldHRlclZhbHVlcyhyZXBsYWNlcikge1xuICAgIHJlcGxhY2VyID0gdHlwZW9mIHJlcGxhY2VyICE9PSBcInVuZGVmaW5lZFwiID8gcmVwbGFjZXIgOiBmdW5jdGlvbihrLCB2KSB7XG4gICAgICByZXR1cm4gdjtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbihrZXksIHZhbCkge1xuICAgICAgaWYgKHJlcGxhY2VyU3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDtpIDwgcmVwbGFjZXJTdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBwYXJ0ID0gcmVwbGFjZXJTdGFja1tpXTtcbiAgICAgICAgICBpZiAocGFydFsxXSA9PT0ga2V5ICYmIHBhcnRbMF0gPT09IHZhbCkge1xuICAgICAgICAgICAgdmFsID0gcGFydFsyXTtcbiAgICAgICAgICAgIHJlcGxhY2VyU3RhY2suc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbCk7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9ldmVudGVtaXR0ZXIzL2luZGV4LmpzXG52YXIgcmVxdWlyZV9ldmVudGVtaXR0ZXIzID0gX19jb21tb25KUygoZXhwb3J0cywgbW9kdWxlKSA9PiB7XG4gIHZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICB2YXIgcHJlZml4ID0gXCJ+XCI7XG4gIGZ1bmN0aW9uIEV2ZW50cygpIHt9XG4gIGlmIChPYmplY3QuY3JlYXRlKSB7XG4gICAgRXZlbnRzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgaWYgKCFuZXcgRXZlbnRzKCkuX19wcm90b19fKVxuICAgICAgcHJlZml4ID0gZmFsc2U7XG4gIH1cbiAgZnVuY3Rpb24gRUUoZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgICB0aGlzLmZuID0gZm47XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLm9uY2UgPSBvbmNlIHx8IGZhbHNlO1xuICB9XG4gIGZ1bmN0aW9uIGFkZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuICAgIHZhciBsaXN0ZW5lciA9IG5ldyBFRShmbiwgY29udGV4dCB8fCBlbWl0dGVyLCBvbmNlKSwgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcbiAgICBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tldnRdKVxuICAgICAgZW1pdHRlci5fZXZlbnRzW2V2dF0gPSBsaXN0ZW5lciwgZW1pdHRlci5fZXZlbnRzQ291bnQrKztcbiAgICBlbHNlIGlmICghZW1pdHRlci5fZXZlbnRzW2V2dF0uZm4pXG4gICAgICBlbWl0dGVyLl9ldmVudHNbZXZ0XS5wdXNoKGxpc3RlbmVyKTtcbiAgICBlbHNlXG4gICAgICBlbWl0dGVyLl9ldmVudHNbZXZ0XSA9IFtlbWl0dGVyLl9ldmVudHNbZXZ0XSwgbGlzdGVuZXJdO1xuICAgIHJldHVybiBlbWl0dGVyO1xuICB9XG4gIGZ1bmN0aW9uIGNsZWFyRXZlbnQoZW1pdHRlciwgZXZ0KSB7XG4gICAgaWYgKC0tZW1pdHRlci5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICBlbWl0dGVyLl9ldmVudHMgPSBuZXcgRXZlbnRzO1xuICAgIGVsc2VcbiAgICAgIGRlbGV0ZSBlbWl0dGVyLl9ldmVudHNbZXZ0XTtcbiAgfVxuICBmdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cztcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgICB2YXIgbmFtZXMgPSBbXSwgZXZlbnRzLCBuYW1lO1xuICAgIGlmICh0aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgIHJldHVybiBuYW1lcztcbiAgICBmb3IgKG5hbWUgaW4gZXZlbnRzID0gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoaGFzLmNhbGwoZXZlbnRzLCBuYW1lKSlcbiAgICAgICAgbmFtZXMucHVzaChwcmVmaXggPyBuYW1lLnNsaWNlKDEpIDogbmFtZSk7XG4gICAgfVxuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICByZXR1cm4gbmFtZXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZXZlbnRzKSk7XG4gICAgfVxuICAgIHJldHVybiBuYW1lcztcbiAgfTtcbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnMoZXZlbnQpIHtcbiAgICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudCwgaGFuZGxlcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcbiAgICBpZiAoIWhhbmRsZXJzKVxuICAgICAgcmV0dXJuIFtdO1xuICAgIGlmIChoYW5kbGVycy5mbilcbiAgICAgIHJldHVybiBbaGFuZGxlcnMuZm5dO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gaGFuZGxlcnMubGVuZ3RoLCBlZSA9IG5ldyBBcnJheShsKTtpIDwgbDsgaSsrKSB7XG4gICAgICBlZVtpXSA9IGhhbmRsZXJzW2ldLmZuO1xuICAgIH1cbiAgICByZXR1cm4gZWU7XG4gIH07XG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIGxpc3RlbmVyQ291bnQoZXZlbnQpIHtcbiAgICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudCwgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG4gICAgaWYgKCFsaXN0ZW5lcnMpXG4gICAgICByZXR1cm4gMDtcbiAgICBpZiAobGlzdGVuZXJzLmZuKVxuICAgICAgcmV0dXJuIDE7XG4gICAgcmV0dXJuIGxpc3RlbmVycy5sZW5ndGg7XG4gIH07XG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZlbnQsIGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICAgIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuICAgIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzLCBpO1xuICAgIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICAgIGlmIChsaXN0ZW5lcnMub25jZSlcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgc3dpdGNoIChsZW4pIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCksIHRydWU7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExKSwgdHJ1ZTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyKSwgdHJ1ZTtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMyksIHRydWU7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0KSwgdHJ1ZTtcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICAgIHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQsIGE1KSwgdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7aSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgfVxuICAgICAgbGlzdGVuZXJzLmZuLmFwcGx5KGxpc3RlbmVycy5jb250ZXh0LCBhcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGgsIGo7XG4gICAgICBmb3IgKGkgPSAwO2kgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAobGlzdGVuZXJzW2ldLm9uY2UpXG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzW2ldLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIsIGEzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAoIWFyZ3MpXG4gICAgICAgICAgICAgIGZvciAoaiA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7aiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tqIC0gMV0gPSBhcmd1bWVudHNbal07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpc3RlbmVyc1tpXS5mbi5hcHBseShsaXN0ZW5lcnNbaV0uY29udGV4dCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbihldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgICByZXR1cm4gYWRkTGlzdGVuZXIodGhpcywgZXZlbnQsIGZuLCBjb250ZXh0LCBmYWxzZSk7XG4gIH07XG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UoZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGFkZExpc3RlbmVyKHRoaXMsIGV2ZW50LCBmbiwgY29udGV4dCwgdHJ1ZSk7XG4gIH07XG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihldmVudCwgZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcbiAgICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgaWYgKCFmbikge1xuICAgICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcbiAgICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gICAgICBpZiAobGlzdGVuZXJzLmZuID09PSBmbiAmJiAoIW9uY2UgfHwgbGlzdGVuZXJzLm9uY2UpICYmICghY29udGV4dCB8fCBsaXN0ZW5lcnMuY29udGV4dCA9PT0gY29udGV4dCkpIHtcbiAgICAgICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgZXZlbnRzID0gW10sIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGg7aSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChsaXN0ZW5lcnNbaV0uZm4gIT09IGZuIHx8IG9uY2UgJiYgIWxpc3RlbmVyc1tpXS5vbmNlIHx8IGNvbnRleHQgJiYgbGlzdGVuZXJzW2ldLmNvbnRleHQgIT09IGNvbnRleHQpIHtcbiAgICAgICAgICBldmVudHMucHVzaChsaXN0ZW5lcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnRzLmxlbmd0aClcbiAgICAgICAgdGhpcy5fZXZlbnRzW2V2dF0gPSBldmVudHMubGVuZ3RoID09PSAxID8gZXZlbnRzWzBdIDogZXZlbnRzO1xuICAgICAgZWxzZVxuICAgICAgICBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyhldmVudCkge1xuICAgIHZhciBldnQ7XG4gICAgaWYgKGV2ZW50KSB7XG4gICAgICBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuICAgICAgaWYgKHRoaXMuX2V2ZW50c1tldnRdKVxuICAgICAgICBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHM7XG4gICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uO1xuICBFdmVudEVtaXR0ZXIucHJlZml4ZWQgPSBwcmVmaXg7XG4gIEV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG4gIGlmICh0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2RhdGEvaXNIZXguanNcbmZ1bmN0aW9uIGlzSGV4KHZhbHVlLCB7IHN0cmljdCA9IHRydWUgfSA9IHt9KSB7XG4gIGlmICghdmFsdWUpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKVxuICAgIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHN0cmljdCA/IC9eMHhbMC05YS1mQS1GXSokLy50ZXN0KHZhbHVlKSA6IHZhbHVlLnN0YXJ0c1dpdGgoXCIweFwiKTtcbn1cblxuLy8gbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zdXBlcnN0cnVjdC9kaXN0L2Vycm9yLm1qc1xuY2xhc3MgU3RydWN0RXJyb3IgZXh0ZW5kcyBUeXBlRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihmYWlsdXJlLCBmYWlsdXJlcykge1xuICAgIGxldCBjYWNoZWQ7XG4gICAgY29uc3QgeyBtZXNzYWdlLCBleHBsYW5hdGlvbiwgLi4ucmVzdCB9ID0gZmFpbHVyZTtcbiAgICBjb25zdCB7IHBhdGggfSA9IGZhaWx1cmU7XG4gICAgY29uc3QgY2F1c2UgPSBwYXRoLmxlbmd0aCA9PT0gMCA/IG1lc3NhZ2UgOiBgQXQgcGF0aDogJHtwYXRoLmpvaW4oXCIuXCIpfSAtLSAke21lc3NhZ2V9YDtcbiAgICBzdXBlcihleHBsYW5hdGlvbiA/PyBjYXVzZSk7XG4gICAgaWYgKGV4cGxhbmF0aW9uICE9PSBudWxsICYmIGV4cGxhbmF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCByZXN0KTtcbiAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgdGhpcy5mYWlsdXJlcyA9ICgpID0+IHtcbiAgICAgIHJldHVybiBjYWNoZWQgPz8gKGNhY2hlZCA9IFtmYWlsdXJlLCAuLi5mYWlsdXJlcygpXSk7XG4gICAgfTtcbiAgfVxufVxuXG4vLyBub2RlX21vZHVsZXMvQG1ldGFtYXNrL3N1cGVyc3RydWN0L2Rpc3QvdXRpbHMubWpzXG5mdW5jdGlvbiBpc0l0ZXJhYmxlKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgdHlwZW9mIHZhbHVlW1N5bWJvbC5pdGVyYXRvcl0gPT09IFwiZnVuY3Rpb25cIjtcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGw7XG59XG5mdW5jdGlvbiBwcmludCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN5bWJvbFwiKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IEpTT04uc3RyaW5naWZ5KHZhbHVlKSA6IGAke3ZhbHVlfWA7XG59XG5mdW5jdGlvbiBzaGlmdEl0ZXJhdG9yKGlucHV0KSB7XG4gIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGlucHV0Lm5leHQoKTtcbiAgcmV0dXJuIGRvbmUgPyB1bmRlZmluZWQgOiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHRvRmFpbHVyZShyZXN1bHQsIGNvbnRleHQsIHN0cnVjdCwgdmFsdWUpIHtcbiAgaWYgKHJlc3VsdCA9PT0gdHJ1ZSkge1xuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgcmVzdWx0ID0ge307XG4gIH0gZWxzZSBpZiAodHlwZW9mIHJlc3VsdCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJlc3VsdCA9IHsgbWVzc2FnZTogcmVzdWx0IH07XG4gIH1cbiAgY29uc3QgeyBwYXRoLCBicmFuY2ggfSA9IGNvbnRleHQ7XG4gIGNvbnN0IHsgdHlwZSB9ID0gc3RydWN0O1xuICBjb25zdCB7IHJlZmluZW1lbnQsIG1lc3NhZ2UgPSBgRXhwZWN0ZWQgYSB2YWx1ZSBvZiB0eXBlIFxcYCR7dHlwZX1cXGAke3JlZmluZW1lbnQgPyBgIHdpdGggcmVmaW5lbWVudCBcXGAke3JlZmluZW1lbnR9XFxgYCA6IFwiXCJ9LCBidXQgcmVjZWl2ZWQ6IFxcYCR7cHJpbnQodmFsdWUpfVxcYGAgfSA9IHJlc3VsdDtcbiAgcmV0dXJuIHtcbiAgICB2YWx1ZSxcbiAgICB0eXBlLFxuICAgIHJlZmluZW1lbnQsXG4gICAga2V5OiBwYXRoW3BhdGgubGVuZ3RoIC0gMV0sXG4gICAgcGF0aCxcbiAgICBicmFuY2gsXG4gICAgLi4ucmVzdWx0LFxuICAgIG1lc3NhZ2VcbiAgfTtcbn1cbmZ1bmN0aW9uKiB0b0ZhaWx1cmVzKHJlc3VsdCwgY29udGV4dCwgc3RydWN0LCB2YWx1ZSkge1xuICBpZiAoIWlzSXRlcmFibGUocmVzdWx0KSkge1xuICAgIHJlc3VsdCA9IFtyZXN1bHRdO1xuICB9XG4gIGZvciAoY29uc3QgdmFsaWRhdGlvblJlc3VsdCBvZiByZXN1bHQpIHtcbiAgICBjb25zdCBmYWlsdXJlID0gdG9GYWlsdXJlKHZhbGlkYXRpb25SZXN1bHQsIGNvbnRleHQsIHN0cnVjdCwgdmFsdWUpO1xuICAgIGlmIChmYWlsdXJlKSB7XG4gICAgICB5aWVsZCBmYWlsdXJlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24qIHJ1bih2YWx1ZSwgc3RydWN0LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgeyBwYXRoID0gW10sIGJyYW5jaCA9IFt2YWx1ZV0sIGNvZXJjZSA9IGZhbHNlLCBtYXNrID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGNvbnRleHQgPSB7IHBhdGgsIGJyYW5jaCB9O1xuICBpZiAoY29lcmNlKSB7XG4gICAgdmFsdWUgPSBzdHJ1Y3QuY29lcmNlcih2YWx1ZSwgY29udGV4dCk7XG4gICAgaWYgKG1hc2sgJiYgc3RydWN0LnR5cGUgIT09IFwidHlwZVwiICYmIGlzT2JqZWN0KHN0cnVjdC5zY2hlbWEpICYmIGlzT2JqZWN0KHZhbHVlKSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgICAgIGlmIChzdHJ1Y3Quc2NoZW1hW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGRlbGV0ZSB2YWx1ZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGxldCBzdGF0dXMgPSBcInZhbGlkXCI7XG4gIGZvciAoY29uc3QgZmFpbHVyZSBvZiBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjb250ZXh0KSkge1xuICAgIGZhaWx1cmUuZXhwbGFuYXRpb24gPSBvcHRpb25zLm1lc3NhZ2U7XG4gICAgc3RhdHVzID0gXCJub3RfdmFsaWRcIjtcbiAgICB5aWVsZCBbZmFpbHVyZSwgdW5kZWZpbmVkXTtcbiAgfVxuICBmb3IgKGxldCBbaW5uZXJLZXksIGlubmVyVmFsdWUsIGlubmVyU3RydWN0XSBvZiBzdHJ1Y3QuZW50cmllcyh2YWx1ZSwgY29udGV4dCkpIHtcbiAgICBjb25zdCBpdGVyYWJsZSA9IHJ1bihpbm5lclZhbHVlLCBpbm5lclN0cnVjdCwge1xuICAgICAgcGF0aDogaW5uZXJLZXkgPT09IHVuZGVmaW5lZCA/IHBhdGggOiBbLi4ucGF0aCwgaW5uZXJLZXldLFxuICAgICAgYnJhbmNoOiBpbm5lcktleSA9PT0gdW5kZWZpbmVkID8gYnJhbmNoIDogWy4uLmJyYW5jaCwgaW5uZXJWYWx1ZV0sXG4gICAgICBjb2VyY2UsXG4gICAgICBtYXNrLFxuICAgICAgbWVzc2FnZTogb3B0aW9ucy5tZXNzYWdlXG4gICAgfSk7XG4gICAgZm9yIChjb25zdCByZXN1bHQgb2YgaXRlcmFibGUpIHtcbiAgICAgIGlmIChyZXN1bHRbMF0pIHtcbiAgICAgICAgc3RhdHVzID0gcmVzdWx0WzBdLnJlZmluZW1lbnQgPT09IG51bGwgfHwgcmVzdWx0WzBdLnJlZmluZW1lbnQgPT09IHVuZGVmaW5lZCA/IFwibm90X3ZhbGlkXCIgOiBcIm5vdF9yZWZpbmVkXCI7XG4gICAgICAgIHlpZWxkIFtyZXN1bHRbMF0sIHVuZGVmaW5lZF07XG4gICAgICB9IGVsc2UgaWYgKGNvZXJjZSkge1xuICAgICAgICBpbm5lclZhbHVlID0gcmVzdWx0WzFdO1xuICAgICAgICBpZiAoaW5uZXJLZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhbHVlID0gaW5uZXJWYWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgIHZhbHVlLnNldChpbm5lcktleSwgaW5uZXJWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgICB2YWx1ZS5hZGQoaW5uZXJWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgaWYgKGlubmVyVmFsdWUgIT09IHVuZGVmaW5lZCB8fCBpbm5lcktleSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgdmFsdWVbaW5uZXJLZXldID0gaW5uZXJWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHN0YXR1cyAhPT0gXCJub3RfdmFsaWRcIikge1xuICAgIGZvciAoY29uc3QgZmFpbHVyZSBvZiBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY29udGV4dCkpIHtcbiAgICAgIGZhaWx1cmUuZXhwbGFuYXRpb24gPSBvcHRpb25zLm1lc3NhZ2U7XG4gICAgICBzdGF0dXMgPSBcIm5vdF9yZWZpbmVkXCI7XG4gICAgICB5aWVsZCBbZmFpbHVyZSwgdW5kZWZpbmVkXTtcbiAgICB9XG4gIH1cbiAgaWYgKHN0YXR1cyA9PT0gXCJ2YWxpZFwiKSB7XG4gICAgeWllbGQgW3VuZGVmaW5lZCwgdmFsdWVdO1xuICB9XG59XG5cbi8vIG5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc3VwZXJzdHJ1Y3QvZGlzdC9zdHJ1Y3QubWpzXG5jbGFzcyBTdHJ1Y3Qge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIGNvbnN0IHsgdHlwZSwgc2NoZW1hLCB2YWxpZGF0b3IsIHJlZmluZXIsIGNvZXJjZXIgPSAodmFsdWUpID0+IHZhbHVlLCBlbnRyaWVzID0gZnVuY3Rpb24qICgpIHt9IH0gPSBwcm9wcztcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICAgIHRoaXMuZW50cmllcyA9IGVudHJpZXM7XG4gICAgdGhpcy5jb2VyY2VyID0gY29lcmNlcjtcbiAgICBpZiAodmFsaWRhdG9yKSB7XG4gICAgICB0aGlzLnZhbGlkYXRvciA9ICh2YWx1ZSwgY29udGV4dCkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0b3IodmFsdWUsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdG9GYWlsdXJlcyhyZXN1bHQsIGNvbnRleHQsIHRoaXMsIHZhbHVlKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudmFsaWRhdG9yID0gKCkgPT4gW107XG4gICAgfVxuICAgIGlmIChyZWZpbmVyKSB7XG4gICAgICB0aGlzLnJlZmluZXIgPSAodmFsdWUsIGNvbnRleHQpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVmaW5lcih2YWx1ZSwgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB0b0ZhaWx1cmVzKHJlc3VsdCwgY29udGV4dCwgdGhpcywgdmFsdWUpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZWZpbmVyID0gKCkgPT4gW107XG4gICAgfVxuICB9XG4gIGFzc2VydCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgIHJldHVybiBhc3NlcnQodmFsdWUsIHRoaXMsIG1lc3NhZ2UpO1xuICB9XG4gIGNyZWF0ZSh2YWx1ZSwgbWVzc2FnZSkge1xuICAgIHJldHVybiBjcmVhdGUodmFsdWUsIHRoaXMsIG1lc3NhZ2UpO1xuICB9XG4gIGlzKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzKHZhbHVlLCB0aGlzKTtcbiAgfVxuICBtYXNrKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG1hc2sodmFsdWUsIHRoaXMsIG1lc3NhZ2UpO1xuICB9XG4gIHZhbGlkYXRlKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gdmFsaWRhdGUodmFsdWUsIHRoaXMsIG9wdGlvbnMpO1xuICB9XG59XG52YXIgRXhhY3RPcHRpb25hbEJyYW5kID0gXCJFWEFDVF9PUFRJT05BTFwiO1xuXG5jbGFzcyBFeGFjdE9wdGlvbmFsU3RydWN0IGV4dGVuZHMgU3RydWN0IHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcih7XG4gICAgICAuLi5wcm9wcyxcbiAgICAgIHR5cGU6IGBleGFjdCBvcHRpb25hbCAke3Byb3BzLnR5cGV9YFxuICAgIH0pO1xuICAgIHRoaXMuYnJhbmQgPSBFeGFjdE9wdGlvbmFsQnJhbmQ7XG4gIH1cbiAgc3RhdGljIGlzRXhhY3RPcHRpb25hbCh2YWx1ZSkge1xuICAgIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgXCJicmFuZFwiIGluIHZhbHVlICYmIHZhbHVlLmJyYW5kID09PSBFeGFjdE9wdGlvbmFsQnJhbmQ7XG4gIH1cbn1cbmZ1bmN0aW9uIGFzc2VydCh2YWx1ZSwgc3RydWN0LCBtZXNzYWdlKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlKHZhbHVlLCBzdHJ1Y3QsIHsgbWVzc2FnZSB9KTtcbiAgaWYgKHJlc3VsdFswXSkge1xuICAgIHRocm93IHJlc3VsdFswXTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlKHZhbHVlLCBzdHJ1Y3QsIG1lc3NhZ2UpIHtcbiAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdGUodmFsdWUsIHN0cnVjdCwgeyBjb2VyY2U6IHRydWUsIG1lc3NhZ2UgfSk7XG4gIGlmIChyZXN1bHRbMF0pIHtcbiAgICB0aHJvdyByZXN1bHRbMF07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJlc3VsdFsxXTtcbiAgfVxufVxuZnVuY3Rpb24gbWFzayh2YWx1ZSwgc3RydWN0LCBtZXNzYWdlKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlKHZhbHVlLCBzdHJ1Y3QsIHsgY29lcmNlOiB0cnVlLCBtYXNrOiB0cnVlLCBtZXNzYWdlIH0pO1xuICBpZiAocmVzdWx0WzBdKSB7XG4gICAgdGhyb3cgcmVzdWx0WzBdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiByZXN1bHRbMV07XG4gIH1cbn1cbmZ1bmN0aW9uIGlzKHZhbHVlLCBzdHJ1Y3QpIHtcbiAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdGUodmFsdWUsIHN0cnVjdCk7XG4gIHJldHVybiAhcmVzdWx0WzBdO1xufVxuZnVuY3Rpb24gdmFsaWRhdGUodmFsdWUsIHN0cnVjdCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHR1cGxlcyA9IHJ1bih2YWx1ZSwgc3RydWN0LCBvcHRpb25zKTtcbiAgY29uc3QgdHVwbGUgPSBzaGlmdEl0ZXJhdG9yKHR1cGxlcyk7XG4gIGlmICh0dXBsZVswXSkge1xuICAgIGNvbnN0IGVycm9yID0gbmV3IFN0cnVjdEVycm9yKHR1cGxlWzBdLCBmdW5jdGlvbiogKCkge1xuICAgICAgZm9yIChjb25zdCBpbm5lclR1cGxlIG9mIHR1cGxlcykge1xuICAgICAgICBpZiAoaW5uZXJUdXBsZVswXSkge1xuICAgICAgICAgIHlpZWxkIGlubmVyVHVwbGVbMF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gW2Vycm9yLCB1bmRlZmluZWRdO1xuICB9XG4gIGNvbnN0IHZhbGlkYXRlZFZhbHVlID0gdHVwbGVbMV07XG4gIHJldHVybiBbdW5kZWZpbmVkLCB2YWxpZGF0ZWRWYWx1ZV07XG59XG5cbi8vIG5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc3VwZXJzdHJ1Y3QvZGlzdC9zdHJ1Y3RzL3V0aWxpdGllcy5tanNcbmZ1bmN0aW9uIGRlZmluZShuYW1lLCB2YWxpZGF0b3IpIHtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3QoeyB0eXBlOiBuYW1lLCBzY2hlbWE6IG51bGwsIHZhbGlkYXRvciB9KTtcbn1cblxuLy8gbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zdXBlcnN0cnVjdC9kaXN0L3N0cnVjdHMvdHlwZXMubWpzXG5mdW5jdGlvbiBhbnkoKSB7XG4gIHJldHVybiBkZWZpbmUoXCJhbnlcIiwgKCkgPT4gdHJ1ZSk7XG59XG5mdW5jdGlvbiBhcnJheShFbGVtZW50KSB7XG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgc2NoZW1hOiBFbGVtZW50LFxuICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICBpZiAoRWxlbWVudCAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBmb3IgKGNvbnN0IFtpbmRleCwgYXJyYXlWYWx1ZV0gb2YgdmFsdWUuZW50cmllcygpKSB7XG4gICAgICAgICAgeWllbGQgW2luZGV4LCBhcnJheVZhbHVlLCBFbGVtZW50XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY29lcmNlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUuc2xpY2UoKSA6IHZhbHVlO1xuICAgIH0sXG4gICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgYEV4cGVjdGVkIGFuIGFycmF5IHZhbHVlLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWA7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGludGVnZXIoKSB7XG4gIHJldHVybiBkZWZpbmUoXCJpbnRlZ2VyXCIsICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgJiYgIWlzTmFOKHZhbHVlKSAmJiBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSB8fCBgRXhwZWN0ZWQgYW4gaW50ZWdlciwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGxpdGVyYWwoY29uc3RhbnQpIHtcbiAgY29uc3QgZGVzY3JpcHRpb24gPSBwcmludChjb25zdGFudCk7XG4gIGNvbnN0IHZhbHVlVHlwZSA9IHR5cGVvZiBjb25zdGFudDtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgIHR5cGU6IFwibGl0ZXJhbFwiLFxuICAgIHNjaGVtYTogdmFsdWVUeXBlID09PSBcInN0cmluZ1wiIHx8IHZhbHVlVHlwZSA9PT0gXCJudW1iZXJcIiB8fCB2YWx1ZVR5cGUgPT09IFwiYm9vbGVhblwiID8gY29uc3RhbnQgOiBudWxsLFxuICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBjb25zdGFudCB8fCBgRXhwZWN0ZWQgdGhlIGxpdGVyYWwgXFxgJHtkZXNjcmlwdGlvbn1cXGAsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YDtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gbmV2ZXIoKSB7XG4gIHJldHVybiBkZWZpbmUoXCJuZXZlclwiLCAoKSA9PiBmYWxzZSk7XG59XG5mdW5jdGlvbiBudWxsYWJsZShzdHJ1Y3QpIHtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgIC4uLnN0cnVjdCxcbiAgICB2YWxpZGF0b3I6ICh2YWx1ZSwgY3R4KSA9PiB2YWx1ZSA9PT0gbnVsbCB8fCBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpLFxuICAgIHJlZmluZXI6ICh2YWx1ZSwgY3R4KSA9PiB2YWx1ZSA9PT0gbnVsbCB8fCBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KVxuICB9KTtcbn1cbmZ1bmN0aW9uIG51bWJlcigpIHtcbiAgcmV0dXJuIGRlZmluZShcIm51bWJlclwiLCAodmFsdWUpID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiICYmICFpc05hTih2YWx1ZSkgfHwgYEV4cGVjdGVkIGEgbnVtYmVyLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWA7XG4gIH0pO1xufVxuZnVuY3Rpb24gb2JqZWN0KHNjaGVtYSkge1xuICBjb25zdCBrbm93bnMgPSBzY2hlbWEgPyBPYmplY3Qua2V5cyhzY2hlbWEpIDogW107XG4gIGNvbnN0IE5ldmVyID0gbmV2ZXIoKTtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgc2NoZW1hOiBzY2hlbWEgPz8gbnVsbCxcbiAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgaWYgKHNjaGVtYSAmJiBpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgY29uc3QgdW5rbm93bnMgPSBuZXcgU2V0KE9iamVjdC5rZXlzKHZhbHVlKSk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtub3ducykge1xuICAgICAgICAgIHVua25vd25zLmRlbGV0ZShrZXkpO1xuICAgICAgICAgIGNvbnN0IHByb3BlcnR5U2NoZW1hID0gc2NoZW1hW2tleV07XG4gICAgICAgICAgaWYgKEV4YWN0T3B0aW9uYWxTdHJ1Y3QuaXNFeGFjdE9wdGlvbmFsKHByb3BlcnR5U2NoZW1hKSAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgeWllbGQgW2tleSwgdmFsdWVba2V5XSwgc2NoZW1hW2tleV1dO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHVua25vd25zKSB7XG4gICAgICAgICAgeWllbGQgW2tleSwgdmFsdWVba2V5XSwgTmV2ZXJdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdCh2YWx1ZSkgfHwgYEV4cGVjdGVkIGFuIG9iamVjdCwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gO1xuICAgIH0sXG4gICAgY29lcmNlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSA/IHsgLi4udmFsdWUgfSA6IHZhbHVlO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBvcHRpb25hbChzdHJ1Y3QpIHtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgIC4uLnN0cnVjdCxcbiAgICB2YWxpZGF0b3I6ICh2YWx1ZSwgY3R4KSA9PiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHN0cnVjdC52YWxpZGF0b3IodmFsdWUsIGN0eCksXG4gICAgcmVmaW5lcjogKHZhbHVlLCBjdHgpID0+IHZhbHVlID09PSB1bmRlZmluZWQgfHwgc3RydWN0LnJlZmluZXIodmFsdWUsIGN0eClcbiAgfSk7XG59XG5mdW5jdGlvbiByZWNvcmQoS2V5LCBWYWx1ZSkge1xuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgdHlwZTogXCJyZWNvcmRcIixcbiAgICBzY2hlbWE6IG51bGwsXG4gICAgKmVudHJpZXModmFsdWUpIHtcbiAgICAgIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgZm9yIChjb25zdCBvYmplY3RLZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgICBjb25zdCBvYmplY3RWYWx1ZSA9IHZhbHVlW29iamVjdEtleV07XG4gICAgICAgICAgeWllbGQgW29iamVjdEtleSwgb2JqZWN0S2V5LCBLZXldO1xuICAgICAgICAgIHlpZWxkIFtvYmplY3RLZXksIG9iamVjdFZhbHVlLCBWYWx1ZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSB8fCBgRXhwZWN0ZWQgYW4gb2JqZWN0LCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWA7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHN0cmluZygpIHtcbiAgcmV0dXJuIGRlZmluZShcInN0cmluZ1wiLCAodmFsdWUpID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IGBFeHBlY3RlZCBhIHN0cmluZywgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHVuaW9uKFN0cnVjdHMpIHtcbiAgY29uc3QgZGVzY3JpcHRpb24gPSBTdHJ1Y3RzLm1hcCgoc3RydWN0KSA9PiBzdHJ1Y3QudHlwZSkuam9pbihcIiB8IFwiKTtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgIHR5cGU6IFwidW5pb25cIixcbiAgICBzY2hlbWE6IG51bGwsXG4gICAgY29lcmNlcih2YWx1ZSkge1xuICAgICAgZm9yIChjb25zdCBJbm5lclN0cnVjdCBvZiBTdHJ1Y3RzKSB7XG4gICAgICAgIGNvbnN0IFtlcnJvciwgY29lcmNlZF0gPSBJbm5lclN0cnVjdC52YWxpZGF0ZSh2YWx1ZSwgeyBjb2VyY2U6IHRydWUgfSk7XG4gICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gY29lcmNlZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgdmFsaWRhdG9yKHZhbHVlLCBjdHgpIHtcbiAgICAgIGNvbnN0IGZhaWx1cmVzID0gW107XG4gICAgICBmb3IgKGNvbnN0IElubmVyU3RydWN0IG9mIFN0cnVjdHMpIHtcbiAgICAgICAgY29uc3QgWy4uLnR1cGxlc10gPSBydW4odmFsdWUsIElubmVyU3RydWN0LCBjdHgpO1xuICAgICAgICBjb25zdCBbZmlyc3RdID0gdHVwbGVzO1xuICAgICAgICBpZiAoIWZpcnN0Py5bMF0pIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBbZmFpbHVyZV0gb2YgdHVwbGVzKSB7XG4gICAgICAgICAgaWYgKGZhaWx1cmUpIHtcbiAgICAgICAgICAgIGZhaWx1cmVzLnB1c2goZmFpbHVyZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gW1xuICAgICAgICBgRXhwZWN0ZWQgdGhlIHZhbHVlIHRvIHNhdGlzZnkgYSB1bmlvbiBvZiBcXGAke2Rlc2NyaXB0aW9ufVxcYCwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gLFxuICAgICAgICAuLi5mYWlsdXJlc1xuICAgICAgXTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gdW5rbm93bigpIHtcbiAgcmV0dXJuIGRlZmluZShcInVua25vd25cIiwgKCkgPT4gdHJ1ZSk7XG59XG5cbi8vIG5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc3VwZXJzdHJ1Y3QvZGlzdC9zdHJ1Y3RzL2NvZXJjaW9ucy5tanNcbmZ1bmN0aW9uIGNvZXJjZShzdHJ1Y3QsIGNvbmRpdGlvbiwgY29lcmNlcikge1xuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgLi4uc3RydWN0LFxuICAgIGNvZXJjZXI6ICh2YWx1ZSwgY3R4KSA9PiB7XG4gICAgICByZXR1cm4gaXModmFsdWUsIGNvbmRpdGlvbikgPyBzdHJ1Y3QuY29lcmNlcihjb2VyY2VyKHZhbHVlLCBjdHgpLCBjdHgpIDogc3RydWN0LmNvZXJjZXIodmFsdWUsIGN0eCk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zdXBlcnN0cnVjdC9kaXN0L3N0cnVjdHMvcmVmaW5lbWVudHMubWpzXG5mdW5jdGlvbiByZWZpbmUoc3RydWN0LCBuYW1lLCByZWZpbmVyKSB7XG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAuLi5zdHJ1Y3QsXG4gICAgKnJlZmluZXIodmFsdWUsIGN0eCkge1xuICAgICAgeWllbGQqIHN0cnVjdC5yZWZpbmVyKHZhbHVlLCBjdHgpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gcmVmaW5lcih2YWx1ZSwgY3R4KTtcbiAgICAgIGNvbnN0IGZhaWx1cmVzID0gdG9GYWlsdXJlcyhyZXN1bHQsIGN0eCwgc3RydWN0LCB2YWx1ZSk7XG4gICAgICBmb3IgKGNvbnN0IGZhaWx1cmUgb2YgZmFpbHVyZXMpIHtcbiAgICAgICAgeWllbGQgeyAuLi5mYWlsdXJlLCByZWZpbmVtZW50OiBuYW1lIH07XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuLy8gbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L21pc2MubWpzXG5mdW5jdGlvbiBpc09iamVjdDIodmFsdWUpIHtcbiAgcmV0dXJuIEJvb2xlYW4odmFsdWUpICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG59XG52YXIgaGFzUHJvcGVydHkgPSAob2JqZWN0VG9DaGVjaywgbmFtZSkgPT4gT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0VG9DaGVjaywgbmFtZSk7XG52YXIgSnNvblNpemU7XG4oZnVuY3Rpb24oSnNvblNpemUyKSB7XG4gIEpzb25TaXplMltKc29uU2l6ZTJbXCJOdWxsXCJdID0gNF0gPSBcIk51bGxcIjtcbiAgSnNvblNpemUyW0pzb25TaXplMltcIkNvbW1hXCJdID0gMV0gPSBcIkNvbW1hXCI7XG4gIEpzb25TaXplMltKc29uU2l6ZTJbXCJXcmFwcGVyXCJdID0gMV0gPSBcIldyYXBwZXJcIjtcbiAgSnNvblNpemUyW0pzb25TaXplMltcIlRydWVcIl0gPSA0XSA9IFwiVHJ1ZVwiO1xuICBKc29uU2l6ZTJbSnNvblNpemUyW1wiRmFsc2VcIl0gPSA1XSA9IFwiRmFsc2VcIjtcbiAgSnNvblNpemUyW0pzb25TaXplMltcIlF1b3RlXCJdID0gMV0gPSBcIlF1b3RlXCI7XG4gIEpzb25TaXplMltKc29uU2l6ZTJbXCJDb2xvblwiXSA9IDFdID0gXCJDb2xvblwiO1xuICBKc29uU2l6ZTJbSnNvblNpemUyW1wiRGF0ZVwiXSA9IDI0XSA9IFwiRGF0ZVwiO1xufSkoSnNvblNpemUgPSBKc29uU2l6ZSB8fCAoSnNvblNpemUgPSB7fSkpO1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHRyeSB7XG4gICAgbGV0IHByb3RvID0gdmFsdWU7XG4gICAgd2hpbGUgKE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90bykgIT09IG51bGwpIHtcbiAgICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkgPT09IHByb3RvO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8vIG5vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9qc29uLm1qc1xudmFyIG9iamVjdDIgPSAoc2NoZW1hKSA9PiBvYmplY3Qoc2NoZW1hKTtcbmZ1bmN0aW9uIGhhc09wdGlvbmFsKHsgcGF0aCwgYnJhbmNoIH0pIHtcbiAgY29uc3QgZmllbGQgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gIHJldHVybiBoYXNQcm9wZXJ0eShicmFuY2hbYnJhbmNoLmxlbmd0aCAtIDJdLCBmaWVsZCk7XG59XG5mdW5jdGlvbiBleGFjdE9wdGlvbmFsKHN0cnVjdCkge1xuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgLi4uc3RydWN0LFxuICAgIHR5cGU6IGBvcHRpb25hbCAke3N0cnVjdC50eXBlfWAsXG4gICAgdmFsaWRhdG9yOiAodmFsdWUsIGNvbnRleHQpID0+ICFoYXNPcHRpb25hbChjb250ZXh0KSB8fCBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjb250ZXh0KSxcbiAgICByZWZpbmVyOiAodmFsdWUsIGNvbnRleHQpID0+ICFoYXNPcHRpb25hbChjb250ZXh0KSB8fCBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY29udGV4dClcbiAgfSk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUpzb24oanNvbikge1xuICBpZiAoanNvbiA9PT0gbnVsbCB8fCB0eXBlb2YganNvbiA9PT0gXCJib29sZWFuXCIgfHwgdHlwZW9mIGpzb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodHlwZW9mIGpzb24gPT09IFwibnVtYmVyXCIgJiYgTnVtYmVyLmlzRmluaXRlKGpzb24pKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHR5cGVvZiBqc29uID09PSBcIm9iamVjdFwiKSB7XG4gICAgbGV0IGV2ZXJ5ID0gdHJ1ZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShqc29uKSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7aSA8IGpzb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCF2YWxpZGF0ZUpzb24oanNvbltpXSkpIHtcbiAgICAgICAgICBldmVyeSA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZXZlcnk7XG4gICAgfVxuICAgIGNvbnN0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhqc29uKTtcbiAgICBmb3IgKGxldCBpID0gMDtpIDwgZW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHR5cGVvZiBlbnRyaWVzW2ldWzBdICE9PSBcInN0cmluZ1wiIHx8ICF2YWxpZGF0ZUpzb24oZW50cmllc1tpXVsxXSkpIHtcbiAgICAgICAgZXZlcnkgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBldmVyeTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG52YXIgVW5zYWZlSnNvblN0cnVjdCA9IGRlZmluZShcIkpTT05cIiwgKGpzb24pID0+IHZhbGlkYXRlSnNvbihqc29uKSk7XG52YXIgSnNvblN0cnVjdCA9IGNvZXJjZShVbnNhZmVKc29uU3RydWN0LCByZWZpbmUoYW55KCksIFwiSlNPTlwiLCAodmFsdWUpID0+IGlzKHZhbHVlLCBVbnNhZmVKc29uU3RydWN0KSksICh2YWx1ZSkgPT4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh2YWx1ZSwgKHByb3BLZXksIHByb3BWYWx1ZSkgPT4ge1xuICBpZiAocHJvcEtleSA9PT0gXCJfX3Byb3RvX19cIiB8fCBwcm9wS2V5ID09PSBcImNvbnN0cnVjdG9yXCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcmV0dXJuIHByb3BWYWx1ZTtcbn0pKSk7XG5mdW5jdGlvbiBpc1ZhbGlkSnNvbih2YWx1ZSkge1xuICB0cnkge1xuICAgIGdldFNhZmVKc29uKHZhbHVlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBnZXRTYWZlSnNvbih2YWx1ZSkge1xuICByZXR1cm4gY3JlYXRlKHZhbHVlLCBKc29uU3RydWN0KTtcbn1cbnZhciBqc29ucnBjMiA9IFwiMi4wXCI7XG52YXIgSnNvblJwY1ZlcnNpb25TdHJ1Y3QgPSBsaXRlcmFsKGpzb25ycGMyKTtcbnZhciBKc29uUnBjSWRTdHJ1Y3QgPSBudWxsYWJsZSh1bmlvbihbbnVtYmVyKCksIHN0cmluZygpXSkpO1xudmFyIEpzb25ScGNFcnJvclN0cnVjdCA9IG9iamVjdDIoe1xuICBjb2RlOiBpbnRlZ2VyKCksXG4gIG1lc3NhZ2U6IHN0cmluZygpLFxuICBkYXRhOiBleGFjdE9wdGlvbmFsKEpzb25TdHJ1Y3QpLFxuICBzdGFjazogZXhhY3RPcHRpb25hbChzdHJpbmcoKSlcbn0pO1xudmFyIEpzb25ScGNQYXJhbXNTdHJ1Y3QgPSB1bmlvbihbcmVjb3JkKHN0cmluZygpLCBKc29uU3RydWN0KSwgYXJyYXkoSnNvblN0cnVjdCldKTtcbnZhciBKc29uUnBjUmVxdWVzdFN0cnVjdCA9IG9iamVjdDIoe1xuICBpZDogSnNvblJwY0lkU3RydWN0LFxuICBqc29ucnBjOiBKc29uUnBjVmVyc2lvblN0cnVjdCxcbiAgbWV0aG9kOiBzdHJpbmcoKSxcbiAgcGFyYW1zOiBleGFjdE9wdGlvbmFsKEpzb25ScGNQYXJhbXNTdHJ1Y3QpXG59KTtcbnZhciBKc29uUnBjTm90aWZpY2F0aW9uU3RydWN0ID0gb2JqZWN0Mih7XG4gIGpzb25ycGM6IEpzb25ScGNWZXJzaW9uU3RydWN0LFxuICBtZXRob2Q6IHN0cmluZygpLFxuICBwYXJhbXM6IGV4YWN0T3B0aW9uYWwoSnNvblJwY1BhcmFtc1N0cnVjdClcbn0pO1xudmFyIFBlbmRpbmdKc29uUnBjUmVzcG9uc2VTdHJ1Y3QgPSBvYmplY3Qoe1xuICBpZDogSnNvblJwY0lkU3RydWN0LFxuICBqc29ucnBjOiBKc29uUnBjVmVyc2lvblN0cnVjdCxcbiAgcmVzdWx0OiBvcHRpb25hbCh1bmtub3duKCkpLFxuICBlcnJvcjogb3B0aW9uYWwoSnNvblJwY0Vycm9yU3RydWN0KVxufSk7XG52YXIgSnNvblJwY1N1Y2Nlc3NTdHJ1Y3QgPSBvYmplY3QyKHtcbiAgaWQ6IEpzb25ScGNJZFN0cnVjdCxcbiAganNvbnJwYzogSnNvblJwY1ZlcnNpb25TdHJ1Y3QsXG4gIHJlc3VsdDogSnNvblN0cnVjdFxufSk7XG52YXIgSnNvblJwY0ZhaWx1cmVTdHJ1Y3QgPSBvYmplY3QyKHtcbiAgaWQ6IEpzb25ScGNJZFN0cnVjdCxcbiAganNvbnJwYzogSnNvblJwY1ZlcnNpb25TdHJ1Y3QsXG4gIGVycm9yOiBKc29uUnBjRXJyb3JTdHJ1Y3Rcbn0pO1xudmFyIEpzb25ScGNSZXNwb25zZVN0cnVjdCA9IHVuaW9uKFtcbiAgSnNvblJwY1N1Y2Nlc3NTdHJ1Y3QsXG4gIEpzb25ScGNGYWlsdXJlU3RydWN0XG5dKTtcbmZ1bmN0aW9uIGlzSnNvblJwY0Vycm9yKHZhbHVlKSB7XG4gIHJldHVybiBpcyh2YWx1ZSwgSnNvblJwY0Vycm9yU3RydWN0KTtcbn1cblxuLy8gbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ycGMtZXJyb3JzL2Rpc3QvY2xhc3Nlcy5tanNcbnZhciBpbXBvcnRfZmFzdF9zYWZlX3N0cmluZ2lmeSA9IF9fdG9FU00ocmVxdWlyZV9mYXN0X3NhZmVfc3RyaW5naWZ5KCksIDEpO1xuXG4vLyBub2RlX21vZHVsZXMvQG1ldGFtYXNrL3JwYy1lcnJvcnMvZGlzdC9lcnJvci1jb25zdGFudHMubWpzXG52YXIgZXJyb3JDb2RlcyA9IHtcbiAgcnBjOiB7XG4gICAgaW52YWxpZElucHV0OiAtMzIwMDAsXG4gICAgcmVzb3VyY2VOb3RGb3VuZDogLTMyMDAxLFxuICAgIHJlc291cmNlVW5hdmFpbGFibGU6IC0zMjAwMixcbiAgICB0cmFuc2FjdGlvblJlamVjdGVkOiAtMzIwMDMsXG4gICAgbWV0aG9kTm90U3VwcG9ydGVkOiAtMzIwMDQsXG4gICAgbGltaXRFeGNlZWRlZDogLTMyMDA1LFxuICAgIHBhcnNlOiAtMzI3MDAsXG4gICAgaW52YWxpZFJlcXVlc3Q6IC0zMjYwMCxcbiAgICBtZXRob2ROb3RGb3VuZDogLTMyNjAxLFxuICAgIGludmFsaWRQYXJhbXM6IC0zMjYwMixcbiAgICBpbnRlcm5hbDogLTMyNjAzXG4gIH0sXG4gIHByb3ZpZGVyOiB7XG4gICAgdXNlclJlamVjdGVkUmVxdWVzdDogNDAwMSxcbiAgICB1bmF1dGhvcml6ZWQ6IDQxMDAsXG4gICAgdW5zdXBwb3J0ZWRNZXRob2Q6IDQyMDAsXG4gICAgZGlzY29ubmVjdGVkOiA0OTAwLFxuICAgIGNoYWluRGlzY29ubmVjdGVkOiA0OTAxXG4gIH1cbn07XG52YXIgZXJyb3JWYWx1ZXMgPSB7XG4gIFwiLTMyNzAwXCI6IHtcbiAgICBzdGFuZGFyZDogXCJKU09OIFJQQyAyLjBcIixcbiAgICBtZXNzYWdlOiBcIkludmFsaWQgSlNPTiB3YXMgcmVjZWl2ZWQgYnkgdGhlIHNlcnZlci4gQW4gZXJyb3Igb2NjdXJyZWQgb24gdGhlIHNlcnZlciB3aGlsZSBwYXJzaW5nIHRoZSBKU09OIHRleHQuXCJcbiAgfSxcbiAgXCItMzI2MDBcIjoge1xuICAgIHN0YW5kYXJkOiBcIkpTT04gUlBDIDIuMFwiLFxuICAgIG1lc3NhZ2U6IFwiVGhlIEpTT04gc2VudCBpcyBub3QgYSB2YWxpZCBSZXF1ZXN0IG9iamVjdC5cIlxuICB9LFxuICBcIi0zMjYwMVwiOiB7XG4gICAgc3RhbmRhcmQ6IFwiSlNPTiBSUEMgMi4wXCIsXG4gICAgbWVzc2FnZTogXCJUaGUgbWV0aG9kIGRvZXMgbm90IGV4aXN0IC8gaXMgbm90IGF2YWlsYWJsZS5cIlxuICB9LFxuICBcIi0zMjYwMlwiOiB7XG4gICAgc3RhbmRhcmQ6IFwiSlNPTiBSUEMgMi4wXCIsXG4gICAgbWVzc2FnZTogXCJJbnZhbGlkIG1ldGhvZCBwYXJhbWV0ZXIocykuXCJcbiAgfSxcbiAgXCItMzI2MDNcIjoge1xuICAgIHN0YW5kYXJkOiBcIkpTT04gUlBDIDIuMFwiLFxuICAgIG1lc3NhZ2U6IFwiSW50ZXJuYWwgSlNPTi1SUEMgZXJyb3IuXCJcbiAgfSxcbiAgXCItMzIwMDBcIjoge1xuICAgIHN0YW5kYXJkOiBcIkVJUC0xNDc0XCIsXG4gICAgbWVzc2FnZTogXCJJbnZhbGlkIGlucHV0LlwiXG4gIH0sXG4gIFwiLTMyMDAxXCI6IHtcbiAgICBzdGFuZGFyZDogXCJFSVAtMTQ3NFwiLFxuICAgIG1lc3NhZ2U6IFwiUmVzb3VyY2Ugbm90IGZvdW5kLlwiXG4gIH0sXG4gIFwiLTMyMDAyXCI6IHtcbiAgICBzdGFuZGFyZDogXCJFSVAtMTQ3NFwiLFxuICAgIG1lc3NhZ2U6IFwiUmVzb3VyY2UgdW5hdmFpbGFibGUuXCJcbiAgfSxcbiAgXCItMzIwMDNcIjoge1xuICAgIHN0YW5kYXJkOiBcIkVJUC0xNDc0XCIsXG4gICAgbWVzc2FnZTogXCJUcmFuc2FjdGlvbiByZWplY3RlZC5cIlxuICB9LFxuICBcIi0zMjAwNFwiOiB7XG4gICAgc3RhbmRhcmQ6IFwiRUlQLTE0NzRcIixcbiAgICBtZXNzYWdlOiBcIk1ldGhvZCBub3Qgc3VwcG9ydGVkLlwiXG4gIH0sXG4gIFwiLTMyMDA1XCI6IHtcbiAgICBzdGFuZGFyZDogXCJFSVAtMTQ3NFwiLFxuICAgIG1lc3NhZ2U6IFwiUmVxdWVzdCBsaW1pdCBleGNlZWRlZC5cIlxuICB9LFxuICBcIjQwMDFcIjoge1xuICAgIHN0YW5kYXJkOiBcIkVJUC0xMTkzXCIsXG4gICAgbWVzc2FnZTogXCJVc2VyIHJlamVjdGVkIHRoZSByZXF1ZXN0LlwiXG4gIH0sXG4gIFwiNDEwMFwiOiB7XG4gICAgc3RhbmRhcmQ6IFwiRUlQLTExOTNcIixcbiAgICBtZXNzYWdlOiBcIlRoZSByZXF1ZXN0ZWQgYWNjb3VudCBhbmQvb3IgbWV0aG9kIGhhcyBub3QgYmVlbiBhdXRob3JpemVkIGJ5IHRoZSB1c2VyLlwiXG4gIH0sXG4gIFwiNDIwMFwiOiB7XG4gICAgc3RhbmRhcmQ6IFwiRUlQLTExOTNcIixcbiAgICBtZXNzYWdlOiBcIlRoZSByZXF1ZXN0ZWQgbWV0aG9kIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBFdGhlcmV1bSBwcm92aWRlci5cIlxuICB9LFxuICBcIjQ5MDBcIjoge1xuICAgIHN0YW5kYXJkOiBcIkVJUC0xMTkzXCIsXG4gICAgbWVzc2FnZTogXCJUaGUgcHJvdmlkZXIgaXMgZGlzY29ubmVjdGVkIGZyb20gYWxsIGNoYWlucy5cIlxuICB9LFxuICBcIjQ5MDFcIjoge1xuICAgIHN0YW5kYXJkOiBcIkVJUC0xMTkzXCIsXG4gICAgbWVzc2FnZTogXCJUaGUgcHJvdmlkZXIgaXMgZGlzY29ubmVjdGVkIGZyb20gdGhlIHNwZWNpZmllZCBjaGFpbi5cIlxuICB9XG59O1xuXG4vLyBub2RlX21vZHVsZXMvQG1ldGFtYXNrL3JwYy1lcnJvcnMvZGlzdC91dGlscy5tanNcbnZhciBGQUxMQkFDS19FUlJPUl9DT0RFID0gZXJyb3JDb2Rlcy5ycGMuaW50ZXJuYWw7XG52YXIgRkFMTEJBQ0tfTUVTU0FHRSA9IFwiVW5zcGVjaWZpZWQgZXJyb3IgbWVzc2FnZS4gVGhpcyBpcyBhIGJ1ZywgcGxlYXNlIHJlcG9ydCBpdC5cIjtcbnZhciBGQUxMQkFDS19FUlJPUiA9IHtcbiAgY29kZTogRkFMTEJBQ0tfRVJST1JfQ09ERSxcbiAgbWVzc2FnZTogZ2V0TWVzc2FnZUZyb21Db2RlKEZBTExCQUNLX0VSUk9SX0NPREUpXG59O1xudmFyIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9NRVNTQUdFID0gXCJVbnNwZWNpZmllZCBzZXJ2ZXIgZXJyb3IuXCI7XG5mdW5jdGlvbiBnZXRNZXNzYWdlRnJvbUNvZGUoY29kZSwgZmFsbGJhY2tNZXNzYWdlID0gRkFMTEJBQ0tfTUVTU0FHRSkge1xuICBpZiAoaXNWYWxpZENvZGUoY29kZSkpIHtcbiAgICBjb25zdCBjb2RlU3RyaW5nID0gY29kZS50b1N0cmluZygpO1xuICAgIGlmIChoYXNQcm9wZXJ0eShlcnJvclZhbHVlcywgY29kZVN0cmluZykpIHtcbiAgICAgIHJldHVybiBlcnJvclZhbHVlc1tjb2RlU3RyaW5nXS5tZXNzYWdlO1xuICAgIH1cbiAgICBpZiAoaXNKc29uUnBjU2VydmVyRXJyb3IoY29kZSkpIHtcbiAgICAgIHJldHVybiBKU09OX1JQQ19TRVJWRVJfRVJST1JfTUVTU0FHRTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbGxiYWNrTWVzc2FnZTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRDb2RlKGNvZGUpIHtcbiAgcmV0dXJuIE51bWJlci5pc0ludGVnZXIoY29kZSk7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVFcnJvcihlcnJvciwgeyBmYWxsYmFja0Vycm9yID0gRkFMTEJBQ0tfRVJST1IsIHNob3VsZEluY2x1ZGVTdGFjayA9IHRydWUsIHNob3VsZFByZXNlcnZlTWVzc2FnZSA9IHRydWUgfSA9IHt9KSB7XG4gIGlmICghaXNKc29uUnBjRXJyb3IoZmFsbGJhY2tFcnJvcikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZmFsbGJhY2sgZXJyb3Igd2l0aCBpbnRlZ2VyIG51bWJlciBjb2RlIGFuZCBzdHJpbmcgbWVzc2FnZS5cIik7XG4gIH1cbiAgY29uc3Qgc2VyaWFsaXplZCA9IGJ1aWxkRXJyb3IoZXJyb3IsIGZhbGxiYWNrRXJyb3IsIHNob3VsZFByZXNlcnZlTWVzc2FnZSk7XG4gIGlmICghc2hvdWxkSW5jbHVkZVN0YWNrKSB7XG4gICAgZGVsZXRlIHNlcmlhbGl6ZWQuc3RhY2s7XG4gIH1cbiAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG59XG5mdW5jdGlvbiBidWlsZEVycm9yKGVycm9yLCBmYWxsYmFja0Vycm9yLCBzaG91bGRQcmVzZXJ2ZU1lc3NhZ2UpIHtcbiAgaWYgKGVycm9yICYmIHR5cGVvZiBlcnJvciA9PT0gXCJvYmplY3RcIiAmJiBcInNlcmlhbGl6ZVwiIGluIGVycm9yICYmIHR5cGVvZiBlcnJvci5zZXJpYWxpemUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBlcnJvci5zZXJpYWxpemUoKTtcbiAgfVxuICBpZiAoaXNKc29uUnBjRXJyb3IoZXJyb3IpKSB7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG4gIGNvbnN0IG9yaWdpbmFsTWVzc2FnZSA9IGdldE9yaWdpbmFsTWVzc2FnZShlcnJvcik7XG4gIGNvbnN0IGNhdXNlID0gc2VyaWFsaXplQ2F1c2UoZXJyb3IpO1xuICBjb25zdCBmYWxsYmFja1dpdGhDYXVzZSA9IHtcbiAgICAuLi5mYWxsYmFja0Vycm9yLFxuICAgIC4uLnNob3VsZFByZXNlcnZlTWVzc2FnZSAmJiBvcmlnaW5hbE1lc3NhZ2UgJiYgeyBtZXNzYWdlOiBvcmlnaW5hbE1lc3NhZ2UgfSxcbiAgICBkYXRhOiB7IGNhdXNlIH1cbiAgfTtcbiAgcmV0dXJuIGZhbGxiYWNrV2l0aENhdXNlO1xufVxuZnVuY3Rpb24gZ2V0T3JpZ2luYWxNZXNzYWdlKGVycm9yKSB7XG4gIGlmIChpc09iamVjdDIoZXJyb3IpICYmIGhhc1Byb3BlcnR5KGVycm9yLCBcIm1lc3NhZ2VcIikgJiYgdHlwZW9mIGVycm9yLm1lc3NhZ2UgPT09IFwic3RyaW5nXCIgJiYgZXJyb3IubWVzc2FnZS5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIGVycm9yLm1lc3NhZ2U7XG4gIH1cbiAgcmV0dXJuO1xufVxuZnVuY3Rpb24gaXNKc29uUnBjU2VydmVyRXJyb3IoY29kZSkge1xuICByZXR1cm4gY29kZSA+PSAtMzIwOTkgJiYgY29kZSA8PSAtMzIwMDA7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVDYXVzZShlcnJvcikge1xuICBpZiAoQXJyYXkuaXNBcnJheShlcnJvcikpIHtcbiAgICByZXR1cm4gZXJyb3IubWFwKChlbnRyeSkgPT4ge1xuICAgICAgaWYgKGlzVmFsaWRKc29uKGVudHJ5KSkge1xuICAgICAgICByZXR1cm4gZW50cnk7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0MihlbnRyeSkpIHtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZU9iamVjdChlbnRyeSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChpc09iamVjdDIoZXJyb3IpKSB7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZU9iamVjdChlcnJvcik7XG4gIH1cbiAgaWYgKGlzVmFsaWRKc29uKGVycm9yKSkge1xuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZU9iamVjdChvYmplY3QzKSB7XG4gIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmplY3QzKS5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSBvYmplY3QzW2tleV07XG4gICAgaWYgKGlzVmFsaWRKc29uKHZhbHVlKSkge1xuICAgICAgYWNjW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xufVxuZnVuY3Rpb24gZGF0YUhhc0NhdXNlKGRhdGEpIHtcbiAgcmV0dXJuIGlzT2JqZWN0MihkYXRhKSAmJiBoYXNQcm9wZXJ0eShkYXRhLCBcImNhdXNlXCIpICYmIGlzT2JqZWN0MihkYXRhLmNhdXNlKTtcbn1cblxuLy8gbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ycGMtZXJyb3JzL2Rpc3QvY2xhc3Nlcy5tanNcbmZ1bmN0aW9uICRpbXBvcnREZWZhdWx0KG1vZHVsZSkge1xuICBpZiAobW9kdWxlPy5fX2VzTW9kdWxlKSB7XG4gICAgcmV0dXJuIG1vZHVsZS5kZWZhdWx0O1xuICB9XG4gIHJldHVybiBtb2R1bGU7XG59XG52YXIgc2FmZVN0cmluZ2lmeSA9ICRpbXBvcnREZWZhdWx0KGltcG9ydF9mYXN0X3NhZmVfc3RyaW5naWZ5LmRlZmF1bHQpO1xuXG5jbGFzcyBKc29uUnBjRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNvZGUsIG1lc3NhZ2UsIGRhdGEpIHtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoY29kZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJjb2RlXCIgbXVzdCBiZSBhbiBpbnRlZ2VyLicpO1xuICAgIH1cbiAgICBpZiAoIW1lc3NhZ2UgfHwgdHlwZW9mIG1lc3NhZ2UgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJtZXNzYWdlXCIgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcuJyk7XG4gICAgfVxuICAgIGlmIChkYXRhSGFzQ2F1c2UoZGF0YSkpIHtcbiAgICAgIHN1cGVyKG1lc3NhZ2UsIHsgY2F1c2U6IGRhdGEuY2F1c2UgfSk7XG4gICAgICBpZiAoIWhhc1Byb3BlcnR5KHRoaXMsIFwiY2F1c2VcIikpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7IGNhdXNlOiBkYXRhLmNhdXNlIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB9XG4gICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgfVxuICBzZXJpYWxpemUoKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IHtcbiAgICAgIGNvZGU6IHRoaXMuY29kZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZVxuICAgIH07XG4gICAgaWYgKHRoaXMuZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzZXJpYWxpemVkLmRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICBpZiAoaXNQbGFpbk9iamVjdCh0aGlzLmRhdGEpKSB7XG4gICAgICAgIHNlcmlhbGl6ZWQuZGF0YS5jYXVzZSA9IHNlcmlhbGl6ZUNhdXNlKHRoaXMuZGF0YS5jYXVzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLnN0YWNrKSB7XG4gICAgICBzZXJpYWxpemVkLnN0YWNrID0gdGhpcy5zdGFjaztcbiAgICB9XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHNhZmVTdHJpbmdpZnkodGhpcy5zZXJpYWxpemUoKSwgc3RyaW5naWZ5UmVwbGFjZXIsIDIpO1xuICB9XG59XG5cbmNsYXNzIEV0aGVyZXVtUHJvdmlkZXJFcnJvciBleHRlbmRzIEpzb25ScGNFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNvZGUsIG1lc3NhZ2UsIGRhdGEpIHtcbiAgICBpZiAoIWlzVmFsaWRFdGhQcm92aWRlckNvZGUoY29kZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJjb2RlXCIgbXVzdCBiZSBhbiBpbnRlZ2VyIHN1Y2ggdGhhdDogMTAwMCA8PSBjb2RlIDw9IDQ5OTknKTtcbiAgICB9XG4gICAgc3VwZXIoY29kZSwgbWVzc2FnZSwgZGF0YSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzVmFsaWRFdGhQcm92aWRlckNvZGUoY29kZSkge1xuICByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcihjb2RlKSAmJiBjb2RlID49IDEwMDAgJiYgY29kZSA8PSA0OTk5O1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5UmVwbGFjZXIoXywgdmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSBcIltDaXJjdWxhcl1cIikge1xuICAgIHJldHVybjtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG4vLyBub2RlX21vZHVsZXMvQG1ldGFtYXNrL3JwYy1lcnJvcnMvZGlzdC9lcnJvcnMubWpzXG52YXIgcnBjRXJyb3JzID0ge1xuICBwYXJzZTogKGFyZykgPT4gZ2V0SnNvblJwY0Vycm9yKGVycm9yQ29kZXMucnBjLnBhcnNlLCBhcmcpLFxuICBpbnZhbGlkUmVxdWVzdDogKGFyZykgPT4gZ2V0SnNvblJwY0Vycm9yKGVycm9yQ29kZXMucnBjLmludmFsaWRSZXF1ZXN0LCBhcmcpLFxuICBpbnZhbGlkUGFyYW1zOiAoYXJnKSA9PiBnZXRKc29uUnBjRXJyb3IoZXJyb3JDb2Rlcy5ycGMuaW52YWxpZFBhcmFtcywgYXJnKSxcbiAgbWV0aG9kTm90Rm91bmQ6IChhcmcpID0+IGdldEpzb25ScGNFcnJvcihlcnJvckNvZGVzLnJwYy5tZXRob2ROb3RGb3VuZCwgYXJnKSxcbiAgaW50ZXJuYWw6IChhcmcpID0+IGdldEpzb25ScGNFcnJvcihlcnJvckNvZGVzLnJwYy5pbnRlcm5hbCwgYXJnKSxcbiAgc2VydmVyOiAob3B0cykgPT4ge1xuICAgIGlmICghb3B0cyB8fCB0eXBlb2Ygb3B0cyAhPT0gXCJvYmplY3RcIiB8fCBBcnJheS5pc0FycmF5KG9wdHMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFdGhlcmV1bSBSUEMgU2VydmVyIGVycm9ycyBtdXN0IHByb3ZpZGUgc2luZ2xlIG9iamVjdCBhcmd1bWVudC5cIik7XG4gICAgfVxuICAgIGNvbnN0IHsgY29kZSB9ID0gb3B0cztcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoY29kZSkgfHwgY29kZSA+IC0zMjAwNSB8fCBjb2RlIDwgLTMyMDk5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiY29kZVwiIG11c3QgYmUgYW4gaW50ZWdlciBzdWNoIHRoYXQ6IC0zMjA5OSA8PSBjb2RlIDw9IC0zMjAwNScpO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0SnNvblJwY0Vycm9yKGNvZGUsIG9wdHMpO1xuICB9LFxuICBpbnZhbGlkSW5wdXQ6IChhcmcpID0+IGdldEpzb25ScGNFcnJvcihlcnJvckNvZGVzLnJwYy5pbnZhbGlkSW5wdXQsIGFyZyksXG4gIHJlc291cmNlTm90Rm91bmQ6IChhcmcpID0+IGdldEpzb25ScGNFcnJvcihlcnJvckNvZGVzLnJwYy5yZXNvdXJjZU5vdEZvdW5kLCBhcmcpLFxuICByZXNvdXJjZVVuYXZhaWxhYmxlOiAoYXJnKSA9PiBnZXRKc29uUnBjRXJyb3IoZXJyb3JDb2Rlcy5ycGMucmVzb3VyY2VVbmF2YWlsYWJsZSwgYXJnKSxcbiAgdHJhbnNhY3Rpb25SZWplY3RlZDogKGFyZykgPT4gZ2V0SnNvblJwY0Vycm9yKGVycm9yQ29kZXMucnBjLnRyYW5zYWN0aW9uUmVqZWN0ZWQsIGFyZyksXG4gIG1ldGhvZE5vdFN1cHBvcnRlZDogKGFyZykgPT4gZ2V0SnNvblJwY0Vycm9yKGVycm9yQ29kZXMucnBjLm1ldGhvZE5vdFN1cHBvcnRlZCwgYXJnKSxcbiAgbGltaXRFeGNlZWRlZDogKGFyZykgPT4gZ2V0SnNvblJwY0Vycm9yKGVycm9yQ29kZXMucnBjLmxpbWl0RXhjZWVkZWQsIGFyZylcbn07XG52YXIgcHJvdmlkZXJFcnJvcnMgPSB7XG4gIHVzZXJSZWplY3RlZFJlcXVlc3Q6IChhcmcpID0+IHtcbiAgICByZXR1cm4gZ2V0RXRoUHJvdmlkZXJFcnJvcihlcnJvckNvZGVzLnByb3ZpZGVyLnVzZXJSZWplY3RlZFJlcXVlc3QsIGFyZyk7XG4gIH0sXG4gIHVuYXV0aG9yaXplZDogKGFyZykgPT4ge1xuICAgIHJldHVybiBnZXRFdGhQcm92aWRlckVycm9yKGVycm9yQ29kZXMucHJvdmlkZXIudW5hdXRob3JpemVkLCBhcmcpO1xuICB9LFxuICB1bnN1cHBvcnRlZE1ldGhvZDogKGFyZykgPT4ge1xuICAgIHJldHVybiBnZXRFdGhQcm92aWRlckVycm9yKGVycm9yQ29kZXMucHJvdmlkZXIudW5zdXBwb3J0ZWRNZXRob2QsIGFyZyk7XG4gIH0sXG4gIGRpc2Nvbm5lY3RlZDogKGFyZykgPT4ge1xuICAgIHJldHVybiBnZXRFdGhQcm92aWRlckVycm9yKGVycm9yQ29kZXMucHJvdmlkZXIuZGlzY29ubmVjdGVkLCBhcmcpO1xuICB9LFxuICBjaGFpbkRpc2Nvbm5lY3RlZDogKGFyZykgPT4ge1xuICAgIHJldHVybiBnZXRFdGhQcm92aWRlckVycm9yKGVycm9yQ29kZXMucHJvdmlkZXIuY2hhaW5EaXNjb25uZWN0ZWQsIGFyZyk7XG4gIH0sXG4gIGN1c3RvbTogKG9wdHMpID0+IHtcbiAgICBpZiAoIW9wdHMgfHwgdHlwZW9mIG9wdHMgIT09IFwib2JqZWN0XCIgfHwgQXJyYXkuaXNBcnJheShvcHRzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXRoZXJldW0gUHJvdmlkZXIgY3VzdG9tIGVycm9ycyBtdXN0IHByb3ZpZGUgc2luZ2xlIG9iamVjdCBhcmd1bWVudC5cIik7XG4gICAgfVxuICAgIGNvbnN0IHsgY29kZSwgbWVzc2FnZSwgZGF0YSB9ID0gb3B0cztcbiAgICBpZiAoIW1lc3NhZ2UgfHwgdHlwZW9mIG1lc3NhZ2UgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJtZXNzYWdlXCIgbXVzdCBiZSBhIG5vbmVtcHR5IHN0cmluZycpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEV0aGVyZXVtUHJvdmlkZXJFcnJvcihjb2RlLCBtZXNzYWdlLCBkYXRhKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGdldEpzb25ScGNFcnJvcihjb2RlLCBhcmcpIHtcbiAgY29uc3QgW21lc3NhZ2UsIGRhdGFdID0gcGFyc2VPcHRzKGFyZyk7XG4gIHJldHVybiBuZXcgSnNvblJwY0Vycm9yKGNvZGUsIG1lc3NhZ2UgPz8gZ2V0TWVzc2FnZUZyb21Db2RlKGNvZGUpLCBkYXRhKTtcbn1cbmZ1bmN0aW9uIGdldEV0aFByb3ZpZGVyRXJyb3IoY29kZSwgYXJnKSB7XG4gIGNvbnN0IFttZXNzYWdlLCBkYXRhXSA9IHBhcnNlT3B0cyhhcmcpO1xuICByZXR1cm4gbmV3IEV0aGVyZXVtUHJvdmlkZXJFcnJvcihjb2RlLCBtZXNzYWdlID8/IGdldE1lc3NhZ2VGcm9tQ29kZShjb2RlKSwgZGF0YSk7XG59XG5mdW5jdGlvbiBwYXJzZU9wdHMoYXJnKSB7XG4gIGlmIChhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIFthcmddO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICBjb25zdCB7IG1lc3NhZ2UsIGRhdGEgfSA9IGFyZztcbiAgICAgIGlmIChtZXNzYWdlICYmIHR5cGVvZiBtZXNzYWdlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3Qgc3BlY2lmeSBzdHJpbmcgbWVzc2FnZS5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gW21lc3NhZ2UgPz8gdW5kZWZpbmVkLCBkYXRhXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtdO1xufVxuLy8gbm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjMvaW5kZXgubWpzXG52YXIgaW1wb3J0X18gPSBfX3RvRVNNKHJlcXVpcmVfZXZlbnRlbWl0dGVyMygpLCAxKTtcblxuLy8gc3JjL3R5cGVzLnRzXG52YXIgR2VtaW5pU2RrRXZlbnQ7XG4oKEdlbWluaVNka0V2ZW50MikgPT4ge1xuICBHZW1pbmlTZGtFdmVudDJbXCJQT1BVUF9MT0FERURcIl0gPSBcIlBPUFVQX0xPQURFRFwiO1xuICBHZW1pbmlTZGtFdmVudDJbXCJQT1BVUF9VTkxPQURFRFwiXSA9IFwiUE9QVVBfVU5MT0FERURcIjtcbiAgR2VtaW5pU2RrRXZlbnQyW1wiUE9QVVBfQVBQX0NPTlRFWFRcIl0gPSBcIlBPUFVQX0FQUF9DT05URVhUXCI7XG4gIEdlbWluaVNka0V2ZW50MltcIlNES19DT05ORUNUXCJdID0gXCJTREtfQ09OTkVDVFwiO1xuICBHZW1pbmlTZGtFdmVudDJbXCJTREtfRElTQ09OTkVDVFwiXSA9IFwiU0RLX0RJU0NPTk5FQ1RcIjtcbiAgR2VtaW5pU2RrRXZlbnQyW1wiU0RLX1NFTkRfVFJBTlNBQ1RJT05cIl0gPSBcIlNES19TRU5EX1RSQU5TQUNUSU9OXCI7XG4gIEdlbWluaVNka0V2ZW50MltcIlNES19TSUdOX0RBVEFcIl0gPSBcIlNES19TSUdOX0RBVEFcIjtcbiAgR2VtaW5pU2RrRXZlbnQyW1wiU0RLX1NJR05fVFlQRURfREFUQVwiXSA9IFwiU0RLX1NJR05fVFlQRURfREFUQVwiO1xuICBHZW1pbmlTZGtFdmVudDJbXCJTREtfU1dJVENIX0NIQUlOXCJdID0gXCJTREtfU1dJVENIX0NIQUlOXCI7XG4gIEdlbWluaVNka0V2ZW50MltcIlNES19PUEVOX1NFVFRJTkdTXCJdID0gXCJTREtfT1BFTl9TRVRUSU5HU1wiO1xufSkoR2VtaW5pU2RrRXZlbnQgfHw9IHt9KTtcbmNsYXNzIFByb3ZpZGVyRXZlbnRFbWl0dGVyIGV4dGVuZHMgaW1wb3J0X18uZGVmYXVsdCB7XG59XG5cbi8vIHNyYy91dGlscy9iYXNlNjQudHNcbmZ1bmN0aW9uIGVuY29kZUJhc2U2NChhcnJheTIpIHtcbiAgbGV0IGJhc2U2NDtcbiAgaWYgKHR5cGVvZiBCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBiYXNlNjQgPSBCdWZmZXIuZnJvbShhcnJheTIpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xuICB9IGVsc2Uge1xuICAgIGJhc2U2NCA9IGJ0b2EoQXJyYXkuZnJvbShhcnJheTIpLm1hcCgoYikgPT4gU3RyaW5nLmZyb21DaGFyQ29kZShiKSkuam9pbihcIlwiKSk7XG4gIH1cbiAgcmV0dXJuIGJhc2U2NC5yZXBsYWNlKC9cXCsvZywgXCItXCIpLnJlcGxhY2UoL1xcLy9nLCBcIl9cIikucmVwbGFjZSgvPSskLywgXCJcIik7XG59XG5mdW5jdGlvbiBkZWNvZGVCYXNlNjQoYmFzZTY0dXJsKSB7XG4gIGxldCBiYXNlNjQgPSBiYXNlNjR1cmwucmVwbGFjZSgvLS9nLCBcIitcIikucmVwbGFjZSgvXy9nLCBcIi9cIik7XG4gIHdoaWxlIChiYXNlNjQubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIGJhc2U2NCArPSBcIj1cIjtcbiAgfVxuICBpZiAodHlwZW9mIEJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShCdWZmZXIuZnJvbShiYXNlNjQsIFwiYmFzZTY0XCIpKTtcbiAgfVxuICBjb25zdCBiaW5hcnlTdHJpbmcgPSBhdG9iKGJhc2U2NCk7XG4gIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYmluYXJ5U3RyaW5nLmxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwO2kgPCBiaW5hcnlTdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICBieXRlc1tpXSA9IGJpbmFyeVN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiBieXRlcztcbn1cbmZ1bmN0aW9uIGJ1ZmZlclRvQmFzZTY0VVJMU3RyaW5nKGJ1ZmZlcikge1xuICBjb25zdCBieXRlcyA9IGJ1ZmZlciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyBidWZmZXIgOiBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICByZXR1cm4gZW5jb2RlQmFzZTY0KGJ5dGVzKTtcbn1cbmZ1bmN0aW9uIHV0ZjhTdHJpbmdUb0J1ZmZlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIFRleHRFbmNvZGVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh2YWx1ZSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoQnVmZmVyLmZyb20odmFsdWUsIFwidXRmOFwiKSk7XG4gIH1cbiAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheSh2YWx1ZS5sZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDtpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICBieXRlc1tpXSA9IHZhbHVlLmNoYXJDb2RlQXQoaSk7XG4gIH1cbiAgcmV0dXJuIGJ5dGVzO1xufVxuZnVuY3Rpb24gYmFzZTY0VG9IZXgoYmFzZTY0KSB7XG4gIGNvbnN0IGJ5dGVzID0gZGVjb2RlQmFzZTY0KGJhc2U2NCk7XG4gIHJldHVybiBBcnJheS5mcm9tKGJ5dGVzKS5tYXAoKGIpID0+IGIudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKSkuam9pbihcIlwiKTtcbn1cbi8vIHNyYy9jb25zdGFudHMudHNcbnZhciBTREtfQkFDS0VORF9VUkwgPSBcImh0dHBzOi8va2V5cy5nZW1pbmkuY29tXCI7XG52YXIgU0RLX1ZFUlNJT04gPSBcIjAuMS4wXCI7XG52YXIgREVGQVVMVF9DSEFJTl9JRCA9IDQyMTYxO1xudmFyIE1BSU5ORVRfQ0hBSU5fSURTID0ge1xuICBFVEhFUkVVTTogMSxcbiAgQVJCSVRSVU1fT05FOiA0MjE2MSxcbiAgT1BfTUFJTk5FVDogMTAsXG4gIEJBU0U6IDg0NTMsXG4gIFBPTFlHT046IDEzN1xufTtcbnZhciBURVNUTkVUX0NIQUlOX0lEUyA9IHtcbiAgU0VQT0xJQTogMTExNTUxMTEsXG4gIEFSQklUUlVNX1NFUE9MSUE6IDQyMTYxNCxcbiAgT1BfU0VQT0xJQTogMTExNTU0MjAsXG4gIEJBU0VfU0VQT0xJQTogODQ1MzIsXG4gIFBPTFlHT05fQU1PWTogODAwMDJcbn07XG52YXIgU1VQUE9SVEVEX0NIQUlOX0lEUyA9IFtcbiAgLi4uT2JqZWN0LnZhbHVlcyhNQUlOTkVUX0NIQUlOX0lEUyksXG4gIC4uLk9iamVjdC52YWx1ZXMoVEVTVE5FVF9DSEFJTl9JRFMpXG5dO1xudmFyIFBPUFVQX1dJRFRIID0gNDIwO1xudmFyIFBPUFVQX0hFSUdIVCA9IDY1MDtcblxuLy8gc3JjL3V0aWxzL3BvcHVwLnRzXG52YXIgb3BlblBvcHVwID0gKHVybCkgPT4ge1xuICBjb25zdCBsZWZ0ID0gKHdpbmRvdy5pbm5lcldpZHRoIC0gUE9QVVBfV0lEVEgpIC8gMiArIHdpbmRvdy5zY3JlZW5YO1xuICBjb25zdCB0b3AgPSAod2luZG93LmlubmVySGVpZ2h0IC0gUE9QVVBfSEVJR0hUKSAvIDIgKyB3aW5kb3cuc2NyZWVuWTtcbiAgY29uc3QgcG9wdXBJZCA9IGBnZW1pbmlfd2FsbGV0XyR7Y3J5cHRvLnJhbmRvbVVVSUQoKX1gO1xuICBjb25zdCBwb3B1cCA9IHdpbmRvdy5vcGVuKHVybCwgcG9wdXBJZCwgYHdpZHRoPSR7UE9QVVBfV0lEVEh9LCBoZWlnaHQ9JHtQT1BVUF9IRUlHSFR9LCBsZWZ0PSR7bGVmdH0sIHRvcD0ke3RvcH1gKTtcbiAgcG9wdXA/LmZvY3VzKCk7XG4gIGlmICghcG9wdXApIHtcbiAgICB0aHJvdyBycGNFcnJvcnMuaW50ZXJuYWwoXCJQb3AgdXAgd2luZG93IGZhaWxlZCB0byBvcGVuXCIpO1xuICB9XG4gIHJldHVybiBwb3B1cDtcbn07XG52YXIgY2xvc2VQb3B1cCA9IChwb3B1cCkgPT4ge1xuICBpZiAocG9wdXAgJiYgIXBvcHVwLmNsb3NlZCkge1xuICAgIHBvcHVwLmNsb3NlKCk7XG4gIH1cbn07XG4vLyBzcmMvdXRpbHMvc3RyaW5ncy50c1xudmFyIGhleFN0cmluZ0Zyb21OdW1iZXIgPSAobnVtKSA9PiBgMHgke0JpZ0ludChudW0pLnRvU3RyaW5nKDE2KX1gO1xudmFyIHNhZmVKc29uU3RyaW5naWZ5ID0gKG9iaikgPT4gSlNPTi5zdHJpbmdpZnkob2JqLCAoXywgdmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIiA/IHZhbHVlLnRvU3RyaW5nKCkgKyBcIm5cIiA6IHZhbHVlLCAyKTtcblxuLy8gc3JjL3V0aWxzL2luZGV4LnRzXG52YXIgZ2VuZXJhdGVSZXF1ZXN0SWQgPSAoKSA9PiBjcnlwdG8ucmFuZG9tVVVJRCgpO1xuXG4vLyBzcmMvY29tbXVuaWNhdG9yLnRzXG5jbGFzcyBDb21tdW5pY2F0b3Ige1xuICBhcHBNZXRhZGF0YTtcbiAgdXJsO1xuICBwb3B1cCA9IG51bGw7XG4gIGxpc3RlbmVycyA9IG5ldyBNYXA7XG4gIG9uRGlzY29ubmVjdENhbGxiYWNrO1xuICBjb25zdHJ1Y3Rvcih7IGFwcE1ldGFkYXRhLCBvbkRpc2Nvbm5lY3RDYWxsYmFjayB9KSB7XG4gICAgdGhpcy51cmwgPSBuZXcgVVJMKFNES19CQUNLRU5EX1VSTCk7XG4gICAgdGhpcy5hcHBNZXRhZGF0YSA9IGFwcE1ldGFkYXRhO1xuICAgIHRoaXMub25EaXNjb25uZWN0Q2FsbGJhY2sgPSBvbkRpc2Nvbm5lY3RDYWxsYmFjaztcbiAgfVxuICBhc3luYyBwb3N0TWVzc2FnZShtZXNzYWdlKSB7XG4gICAgY29uc3QgcG9wdXAgPSBhd2FpdCB0aGlzLndhaXRGb3JQb3B1cExvYWRlZCgpO1xuICAgIHBvcHVwLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIHRoaXMudXJsLm9yaWdpbik7XG4gIH1cbiAgYXN5bmMgcG9zdFJlcXVlc3RBbmRXYWl0Rm9yUmVzcG9uc2UocmVxdWVzdCkge1xuICAgIGNvbnN0IHJlc3BvbnNlUHJvbWlzZSA9IHRoaXMub25NZXNzYWdlKCh7IHJlcXVlc3RJZCB9KSA9PiByZXF1ZXN0SWQgPT09IHJlcXVlc3QucmVxdWVzdElkKTtcbiAgICBhd2FpdCB0aGlzLnBvc3RNZXNzYWdlKHJlcXVlc3QpO1xuICAgIHJldHVybiByZXNwb25zZVByb21pc2U7XG4gIH1cbiAgYXN5bmMgb25NZXNzYWdlKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBsaXN0ZW5lciA9IChldmVudCkgPT4ge1xuICAgICAgICBpZiAoZXZlbnQub3JpZ2luICE9PSB0aGlzLnVybC5vcmlnaW4pXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgaWYgKHByZWRpY2F0ZShtZXNzYWdlKSkge1xuICAgICAgICAgIHJlc29sdmUobWVzc2FnZSk7XG4gICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGxpc3RlbmVyKTtcbiAgICAgICAgICB0aGlzLmxpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGxpc3RlbmVyKTtcbiAgICAgIHRoaXMubGlzdGVuZXJzLnNldChsaXN0ZW5lciwgeyByZWplY3QgfSk7XG4gICAgfSk7XG4gIH1cbiAgb25SZXF1ZXN0Q2FuY2VsbGVkKCkge1xuICAgIGNsb3NlUG9wdXAodGhpcy5wb3B1cCA/PyB1bmRlZmluZWQpO1xuICAgIHRoaXMucG9wdXAgPSBudWxsO1xuICAgIHRoaXMubGlzdGVuZXJzLmZvckVhY2goKHsgcmVqZWN0IH0sIGxpc3RlbmVyKSA9PiB7XG4gICAgICByZWplY3QocHJvdmlkZXJFcnJvcnMudXNlclJlamVjdGVkUmVxdWVzdCgpKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBsaXN0ZW5lcik7XG4gICAgfSk7XG4gICAgdGhpcy5saXN0ZW5lcnMuY2xlYXIoKTtcbiAgfVxuICBhc3luYyB3YWl0Rm9yUG9wdXBMb2FkZWQoKSB7XG4gICAgaWYgKHRoaXMucG9wdXAgJiYgIXRoaXMucG9wdXAuY2xvc2VkKSB7XG4gICAgICB0aGlzLnBvcHVwLmZvY3VzKCk7XG4gICAgICByZXR1cm4gdGhpcy5wb3B1cDtcbiAgICB9XG4gICAgdGhpcy5wb3B1cCA9IG9wZW5Qb3B1cCh0aGlzLnVybCk7XG4gICAgdGhpcy5vbk1lc3NhZ2UoKHsgZXZlbnQgfSkgPT4gZXZlbnQgPT09IFwiUE9QVVBfVU5MT0FERURcIiAvKiBQT1BVUF9VTkxPQURFRCAqLykudGhlbigoKSA9PiB0aGlzLm9uUmVxdWVzdENhbmNlbGxlZCgpKS5jYXRjaCgoKSA9PiB7fSk7XG4gICAgdGhpcy5vbk1lc3NhZ2UoKHsgZXZlbnQgfSkgPT4gZXZlbnQgPT09IFwiU0RLX0RJU0NPTk5FQ1RcIiAvKiBTREtfRElTQ09OTkVDVCAqLykudGhlbigoKSA9PiB7XG4gICAgICB0aGlzLm9uRGlzY29ubmVjdENhbGxiYWNrPy4oKTtcbiAgICAgIHRoaXMub25SZXF1ZXN0Q2FuY2VsbGVkKCk7XG4gICAgfSkuY2F0Y2goKCkgPT4ge30pO1xuICAgIHJldHVybiB0aGlzLm9uTWVzc2FnZSgoeyBldmVudCB9KSA9PiBldmVudCA9PT0gXCJQT1BVUF9MT0FERURcIiAvKiBQT1BVUF9MT0FERUQgKi8pLnRoZW4oKG1lc3NhZ2UpID0+IHtcbiAgICAgIHRoaXMucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBjaGFpbklkOiBERUZBVUxUX0NIQUlOX0lELFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgYXBwTWV0YWRhdGE6IHRoaXMuYXBwTWV0YWRhdGEsXG4gICAgICAgICAgb3JpZ2luOiB3aW5kb3cubG9jYXRpb24ub3JpZ2luLFxuICAgICAgICAgIHNka1ZlcnNpb246IFNES19WRVJTSU9OXG4gICAgICAgIH0sXG4gICAgICAgIGV2ZW50OiBcIlBPUFVQX0FQUF9DT05URVhUXCIgLyogUE9QVVBfQVBQX0NPTlRFWFQgKi8sXG4gICAgICAgIG9yaWdpbjogd2luZG93LmxvY2F0aW9uLm9yaWdpbixcbiAgICAgICAgcmVxdWVzdElkOiBtZXNzYWdlLnJlcXVlc3RJZFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgIGlmICghdGhpcy5wb3B1cClcbiAgICAgICAgdGhyb3cgcnBjRXJyb3JzLmludGVybmFsKCk7XG4gICAgICByZXR1cm4gdGhpcy5wb3B1cDtcbiAgICB9KTtcbiAgfVxufVxuLy8gc3JjL3N0b3JhZ2Uvc3RvcmFnZUludGVyZmFjZS50c1xudmFyIFNUT1JBR0VfRVRIX0FDQ09VTlRTX0tFWSA9IFwiZXRoLWFjY291bnRzXCI7XG52YXIgU1RPUkFHRV9FVEhfQUNUSVZFX0NIQUlOX0tFWSA9IFwiZXRoLWFjdGl2ZS1jaGFpblwiO1xudmFyIFNUT1JBR0VfUEFTU0tFWV9DUkVERU5USUFMX0tFWSA9IFwicGFzc2tleS1jcmVkZW50aWFsXCI7XG52YXIgU1RPUkFHRV9TTUFSVF9BQ0NPVU5UX0tFWSA9IFwic21hcnQtYWNjb3VudFwiO1xudmFyIFNUT1JBR0VfU0VUVElOR1NfS0VZID0gXCJzZXR0aW5nc1wiO1xuXG4vLyBzcmMvc3RvcmFnZS9zdG9yYWdlLnRzXG52YXIgbWVtb3J5U3RvcmFnZSA9IHt9O1xuY2xhc3MgR2VtaW5pU3RvcmFnZSB7XG4gIHNjb3BlID0gXCJAZ2VtaW5pXCI7XG4gIG1vZHVsZSA9IFwid2FsbGV0XCI7XG4gIHNjb3BlZEtleShrZXkpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5zY29wZX0uJHt0aGlzLm1vZHVsZX0uJHtrZXl9YDtcbiAgfVxuICBhc3luYyBzdG9yZU9iamVjdChrZXksIGl0ZW0pIHtcbiAgICBjb25zdCBqc29uID0gc2FmZUpzb25TdHJpbmdpZnkoaXRlbSk7XG4gICAgYXdhaXQgdGhpcy5zZXRJdGVtKGtleSwganNvbik7XG4gIH1cbiAgYXN5bmMgbG9hZE9iamVjdChrZXksIGZhbGxiYWNrKSB7XG4gICAgY29uc3QgaXRlbSA9IGF3YWl0IHRoaXMuZ2V0SXRlbShrZXkpO1xuICAgIGlmICghaXRlbSkge1xuICAgICAgYXdhaXQgdGhpcy5zdG9yZU9iamVjdChrZXksIGZhbGxiYWNrKTtcbiAgICAgIHJldHVybiBmYWxsYmFjaztcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKGl0ZW0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBwYXJzaW5nIEpTT04gZm9yIGtleSAke2tleX06YCwgZXJyb3IpO1xuICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgIH1cbiAgfVxuICBzZXRJdGVtKGtleSwgdmFsdWUpIHtcbiAgICBjb25zdCBzY29wZWQgPSB0aGlzLnNjb3BlZEtleShrZXkpO1xuICAgIHRyeSB7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShzY29wZWQsIHZhbHVlKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIG1lbW9yeVN0b3JhZ2Vbc2NvcGVkXSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cbiAgZ2V0SXRlbShrZXkpIHtcbiAgICBjb25zdCBzY29wZWQgPSB0aGlzLnNjb3BlZEtleShrZXkpO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKHNjb3BlZCkgPz8gdW5kZWZpbmVkKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWVtb3J5U3RvcmFnZVtzY29wZWRdIHx8IHVuZGVmaW5lZCk7XG4gICAgfVxuICB9XG4gIHJlbW92ZUl0ZW0oa2V5KSB7XG4gICAgY29uc3Qgc2NvcGVkID0gdGhpcy5zY29wZWRLZXkoa2V5KTtcbiAgICB0cnkge1xuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oc2NvcGVkKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIGRlbGV0ZSBtZW1vcnlTdG9yYWdlW3Njb3BlZF07XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxufVxuLy8gc3JjL3dhbGxldHMvd2FsbGV0LnRzXG5mdW5jdGlvbiBpc0NoYWluU3VwcG9ydGVkQnlHZW1pbmlTdyhjaGFpbklkKSB7XG4gIHJldHVybiBTVVBQT1JURURfQ0hBSU5fSURTLmluY2x1ZGVzKGNoYWluSWQpO1xufVxuXG5jbGFzcyBHZW1pbmlXYWxsZXQge1xuICBjb21tdW5pY2F0b3I7XG4gIHN0b3JhZ2U7XG4gIGluaXRQcm9taXNlO1xuICBhY2NvdW50cyA9IFtdO1xuICBjaGFpbiA9IHsgaWQ6IERFRkFVTFRfQ0hBSU5fSUQgfTtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGFwcE1ldGFkYXRhLFxuICAgIGNoYWluLFxuICAgIG9uRGlzY29ubmVjdENhbGxiYWNrLFxuICAgIHN0b3JhZ2VcbiAgfSkge1xuICAgIHRoaXMuY29tbXVuaWNhdG9yID0gbmV3IENvbW11bmljYXRvcih7XG4gICAgICBhcHBNZXRhZGF0YSxcbiAgICAgIG9uRGlzY29ubmVjdENhbGxiYWNrXG4gICAgfSk7XG4gICAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZSB8fCBuZXcgR2VtaW5pU3RvcmFnZTtcbiAgICB0aGlzLmluaXRQcm9taXNlID0gdGhpcy5pbml0aWFsaXplRnJvbVN0b3JhZ2UoY2hhaW4/LmlkID8/IHRoaXMuY2hhaW4uaWQpO1xuICB9XG4gIGFzeW5jIGluaXRpYWxpemVGcm9tU3RvcmFnZShkZWZhdWx0Q2hhaW5JZCkge1xuICAgIGNvbnN0IFtzdG9yZWRDaGFpbiwgc3RvcmVkQWNjb3VudHNdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgdGhpcy5zdG9yYWdlLmxvYWRPYmplY3QoU1RPUkFHRV9FVEhfQUNUSVZFX0NIQUlOX0tFWSwge1xuICAgICAgICBpZDogZGVmYXVsdENoYWluSWRcbiAgICAgIH0pLFxuICAgICAgdGhpcy5zdG9yYWdlLmxvYWRPYmplY3QoU1RPUkFHRV9FVEhfQUNDT1VOVFNfS0VZLCB0aGlzLmFjY291bnRzKVxuICAgIF0pO1xuICAgIHRoaXMuY2hhaW4gPSBzdG9yZWRDaGFpbjtcbiAgICB0aGlzLmFjY291bnRzID0gc3RvcmVkQWNjb3VudHM7XG4gIH1cbiAgYXN5bmMgZW5zdXJlSW5pdGlhbGl6ZWQoKSB7XG4gICAgYXdhaXQgdGhpcy5pbml0UHJvbWlzZTtcbiAgfVxuICBhc3luYyBjb25uZWN0KCkge1xuICAgIGF3YWl0IHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuc2VuZE1lc3NhZ2VUb1BvcHVwKHtcbiAgICAgIGNoYWluSWQ6IHRoaXMuY2hhaW4uaWQsXG4gICAgICBldmVudDogXCJTREtfQ09OTkVDVFwiIC8qIFNES19DT05ORUNUICovLFxuICAgICAgb3JpZ2luOiB3aW5kb3cubG9jYXRpb24ub3JpZ2luXG4gICAgfSk7XG4gICAgdGhpcy5hY2NvdW50cyA9IFtyZXNwb25zZS5kYXRhLmFkZHJlc3NdO1xuICAgIGF3YWl0IHRoaXMuc3RvcmFnZS5zdG9yZU9iamVjdChTVE9SQUdFX0VUSF9BQ0NPVU5UU19LRVksIHRoaXMuYWNjb3VudHMpO1xuICAgIHJldHVybiB0aGlzLmFjY291bnRzO1xuICB9XG4gIGFzeW5jIHN3aXRjaENoYWluKHtcbiAgICBpZFxuICB9KSB7XG4gICAgYXdhaXQgdGhpcy5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgIGlmIChpc0NoYWluU3VwcG9ydGVkQnlHZW1pbmlTdyhpZCkpIHtcbiAgICAgIHRoaXMuY2hhaW4gPSB7IGlkIH07XG4gICAgICBhd2FpdCB0aGlzLnN0b3JhZ2Uuc3RvcmVPYmplY3QoU1RPUkFHRV9FVEhfQUNUSVZFX0NIQUlOX0tFWSwgeyBpZCB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnNlbmRNZXNzYWdlVG9Qb3B1cCh7XG4gICAgICBjaGFpbklkOiB0aGlzLmNoYWluLmlkLFxuICAgICAgZGF0YTogaWQsXG4gICAgICBldmVudDogXCJTREtfU1dJVENIX0NIQUlOXCIgLyogU0RLX1NXSVRDSF9DSEFJTiAqLyxcbiAgICAgIG9yaWdpbjogd2luZG93LmxvY2F0aW9uLm9yaWdpblxuICAgIH0pO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhLmVycm9yO1xuICB9XG4gIGFzeW5jIHNlbmRUcmFuc2FjdGlvbih0eERhdGEpIHtcbiAgICBhd2FpdCB0aGlzLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnNlbmRNZXNzYWdlVG9Qb3B1cCh7XG4gICAgICBjaGFpbklkOiB0aGlzLmNoYWluLmlkLFxuICAgICAgZGF0YTogdHhEYXRhLFxuICAgICAgZXZlbnQ6IFwiU0RLX1NFTkRfVFJBTlNBQ1RJT05cIiAvKiBTREtfU0VORF9UUkFOU0FDVElPTiAqLyxcbiAgICAgIG9yaWdpbjogd2luZG93LmxvY2F0aW9uLm9yaWdpblxuICAgIH0pO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9XG4gIGFzeW5jIHNpZ25EYXRhKHtcbiAgICBtZXNzYWdlXG4gIH0pIHtcbiAgICBhd2FpdCB0aGlzLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnNlbmRNZXNzYWdlVG9Qb3B1cCh7XG4gICAgICBjaGFpbklkOiB0aGlzLmNoYWluLmlkLFxuICAgICAgZGF0YTogeyBtZXNzYWdlIH0sXG4gICAgICBldmVudDogXCJTREtfU0lHTl9EQVRBXCIgLyogU0RLX1NJR05fREFUQSAqLyxcbiAgICAgIG9yaWdpbjogd2luZG93LmxvY2F0aW9uLm9yaWdpblxuICAgIH0pO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9XG4gIGFzeW5jIHNpZ25UeXBlZERhdGEoe1xuICAgIG1lc3NhZ2UsXG4gICAgdHlwZXMsXG4gICAgcHJpbWFyeVR5cGUsXG4gICAgZG9tYWluXG4gIH0pIHtcbiAgICBhd2FpdCB0aGlzLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnNlbmRNZXNzYWdlVG9Qb3B1cCh7XG4gICAgICBjaGFpbklkOiB0aGlzLmNoYWluLmlkLFxuICAgICAgZGF0YToge1xuICAgICAgICBkb21haW4sXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIHByaW1hcnlUeXBlLFxuICAgICAgICB0eXBlc1xuICAgICAgfSxcbiAgICAgIGV2ZW50OiBcIlNES19TSUdOX1RZUEVEX0RBVEFcIiAvKiBTREtfU0lHTl9UWVBFRF9EQVRBICovLFxuICAgICAgb3JpZ2luOiB3aW5kb3cubG9jYXRpb24ub3JpZ2luXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH1cbiAgYXN5bmMgb3BlblNldHRpbmdzKCkge1xuICAgIGF3YWl0IHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICBhd2FpdCB0aGlzLnNlbmRNZXNzYWdlVG9Qb3B1cCh7XG4gICAgICBjaGFpbklkOiB0aGlzLmNoYWluLmlkLFxuICAgICAgZGF0YToge30sXG4gICAgICBldmVudDogXCJTREtfT1BFTl9TRVRUSU5HU1wiIC8qIFNES19PUEVOX1NFVFRJTkdTICovLFxuICAgICAgb3JpZ2luOiB3aW5kb3cubG9jYXRpb24ub3JpZ2luXG4gICAgfSk7XG4gIH1cbiAgc2VuZE1lc3NhZ2VUb1BvcHVwKHJlcXVlc3QpIHtcbiAgICByZXR1cm4gdGhpcy5jb21tdW5pY2F0b3IucG9zdFJlcXVlc3RBbmRXYWl0Rm9yUmVzcG9uc2Uoe1xuICAgICAgLi4ucmVxdWVzdCxcbiAgICAgIHJlcXVlc3RJZDogd2luZG93Py5jcnlwdG8/LnJhbmRvbVVVSUQoKVxuICAgIH0pO1xuICB9XG59XG4vLyBzcmMvcHJvdmlkZXIvcHJvdmlkZXIudXRpbHMudHNcbnZhciBmZXRjaFJwY1JlcXVlc3QgPSBhc3luYyAocmVxdWVzdCwgcnBjVXJsKSA9PiB7XG4gIGNvbnN0IHJlcXVlc3RCb2R5ID0ge1xuICAgIC4uLnJlcXVlc3QsXG4gICAgaWQ6IHdpbmRvdz8uY3J5cHRvPy5yYW5kb21VVUlEKCksXG4gICAganNvbnJwYzogXCIyLjBcIlxuICB9O1xuICBjb25zdCByZXMgPSBhd2FpdCB3aW5kb3cuZmV0Y2gocnBjVXJsLCB7XG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkocmVxdWVzdEJvZHkpLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgfSxcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIG1vZGU6IFwiY29yc1wiXG4gIH0pO1xuICBjb25zdCB7IHJlc3VsdCwgZXJyb3IgfSA9IGF3YWl0IHJlcy5qc29uKCk7XG4gIGlmIChlcnJvcikge1xuICAgIHRocm93IGVycm9yO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuZnVuY3Rpb24gdmFsaWRhdGVScGNSZXF1ZXN0QXJncyhhcmdzKSB7XG4gIGlmICghYXJncyB8fCB0eXBlb2YgYXJncyAhPT0gXCJvYmplY3RcIiB8fCBBcnJheS5pc0FycmF5KGFyZ3MpKSB7XG4gICAgdGhyb3cgcnBjRXJyb3JzLmludmFsaWRQYXJhbXMoe1xuICAgICAgbWVzc2FnZTogXCJFeHBlY3RlZCBhIHNpbmdsZSwgbm9uLWFycmF5LCBvYmplY3QgYXJndW1lbnQuXCJcbiAgICB9KTtcbiAgfVxuICBjb25zdCB7IG1ldGhvZCwgcGFyYW1zIH0gPSBhcmdzO1xuICBpZiAodHlwZW9mIG1ldGhvZCAhPT0gXCJzdHJpbmdcIiB8fCBtZXRob2QubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgcnBjRXJyb3JzLmludmFsaWRQYXJhbXMoe1xuICAgICAgbWVzc2FnZTogXCInYXJncy5tZXRob2QnIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nLlwiXG4gICAgfSk7XG4gIH1cbiAgaWYgKHBhcmFtcyAhPT0gdW5kZWZpbmVkICYmICFBcnJheS5pc0FycmF5KHBhcmFtcykgJiYgKHR5cGVvZiBwYXJhbXMgIT09IFwib2JqZWN0XCIgfHwgcGFyYW1zID09PSBudWxsKSkge1xuICAgIHRocm93IHJwY0Vycm9ycy5pbnZhbGlkUGFyYW1zKHtcbiAgICAgIG1lc3NhZ2U6IFwiJ2FyZ3MucGFyYW1zJyBtdXN0IGJlIGFuIG9iamVjdCBvciBhcnJheSBpZiBwcm92aWRlZC5cIlxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBjb252ZXJ0U2VuZFZhbHVlc1RvQmlnSW50KHR4KSB7XG4gIGNvbnN0IEZJRUxEU19UT19OT1JNQUxJWkUgPSBbXCJ2YWx1ZVwiLCBcImdhc1wiLCBcImdhc1ByaWNlXCIsIFwibWF4UHJpb3JpdHlGZWVQZXJHYXNcIiwgXCJtYXhGZWVQZXJHYXNcIl07XG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSB7IC4uLnR4IH07XG4gIGZvciAoY29uc3QgZmllbGQgb2YgRklFTERTX1RPX05PUk1BTElaRSkge1xuICAgIGlmICghKGZpZWxkIGluIHR4KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gdHhbZmllbGRdO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoaXNIZXgodmFsdWUpKSB7XG4gICAgICBub3JtYWxpemVkW2ZpZWxkXSA9IEJpZ0ludCh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBub3JtYWxpemVkO1xufVxuXG4vLyBzcmMvcHJvdmlkZXIvcHJvdmlkZXIudHNcbmNsYXNzIEdlbWluaVdhbGxldFByb3ZpZGVyIGV4dGVuZHMgUHJvdmlkZXJFdmVudEVtaXR0ZXIge1xuICBjb25maWc7XG4gIHdhbGxldCA9IHVuZGVmaW5lZDtcbiAgY29uc3RydWN0b3IocHJvdmlkZXJDb25maWcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY29uZmlnID0gcHJvdmlkZXJDb25maWc7XG4gICAgdGhpcy53YWxsZXQgPSBuZXcgR2VtaW5pV2FsbGV0KHtcbiAgICAgIC4uLnByb3ZpZGVyQ29uZmlnLFxuICAgICAgb25EaXNjb25uZWN0Q2FsbGJhY2s6IHRoaXMuZGlzY29ubmVjdC5iaW5kKHRoaXMpXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgcmVxdWVzdChhcmdzKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhbGlkYXRlUnBjUmVxdWVzdEFyZ3MoYXJncyk7XG4gICAgICBpZiAoIXRoaXMud2FsbGV0Py5hY2NvdW50cz8ubGVuZ3RoKSB7XG4gICAgICAgIHN3aXRjaCAoYXJncy5tZXRob2QpIHtcbiAgICAgICAgICBjYXNlIFwiZXRoX3JlcXVlc3RBY2NvdW50c1wiOiB7XG4gICAgICAgICAgICB0aGlzLndhbGxldCA9IG5ldyBHZW1pbmlXYWxsZXQoe1xuICAgICAgICAgICAgICAuLi50aGlzLmNvbmZpZyxcbiAgICAgICAgICAgICAgb25EaXNjb25uZWN0Q2FsbGJhY2s6IHRoaXMuZGlzY29ubmVjdC5iaW5kKHRoaXMpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMud2FsbGV0LmNvbm5lY3QoKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImFjY291bnRzQ2hhbmdlZFwiLCB0aGlzLndhbGxldC5hY2NvdW50cyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIm5ldF92ZXJzaW9uXCI6XG4gICAgICAgICAgICByZXR1cm4gREVGQVVMVF9DSEFJTl9JRDtcbiAgICAgICAgICBjYXNlIFwiZXRoX2NoYWluSWRcIjpcbiAgICAgICAgICAgIHJldHVybiBoZXhTdHJpbmdGcm9tTnVtYmVyKERFRkFVTFRfQ0hBSU5fSUQpO1xuICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIHRocm93IHByb3ZpZGVyRXJyb3JzLnVuYXV0aG9yaXplZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgbGV0IHJlcXVlc3RQYXJhbXM7XG4gICAgICBzd2l0Y2ggKGFyZ3MubWV0aG9kKSB7XG4gICAgICAgIGNhc2UgXCJldGhfcmVxdWVzdEFjY291bnRzXCI6XG4gICAgICAgIGNhc2UgXCJldGhfYWNjb3VudHNcIjpcbiAgICAgICAgICByZXNwb25zZSA9IHRoaXMud2FsbGV0LmFjY291bnRzO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibmV0X3ZlcnNpb25cIjpcbiAgICAgICAgICByZXNwb25zZSA9IHRoaXMud2FsbGV0LmNoYWluLmlkO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZXRoX2NoYWluSWRcIjpcbiAgICAgICAgICByZXNwb25zZSA9IGhleFN0cmluZ0Zyb21OdW1iZXIodGhpcy53YWxsZXQuY2hhaW4uaWQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicGVyc29uYWxfc2lnblwiOlxuICAgICAgICBjYXNlIFwid2FsbGV0X3NpZ25cIjpcbiAgICAgICAgICByZXF1ZXN0UGFyYW1zID0gYXJncy5wYXJhbXM7XG4gICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLndhbGxldC5zaWduRGF0YSh7XG4gICAgICAgICAgICBhY2NvdW50OiByZXF1ZXN0UGFyYW1zWzFdLFxuICAgICAgICAgICAgbWVzc2FnZTogcmVxdWVzdFBhcmFtc1swXVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChyZXNwb25zZS5lcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgcnBjRXJyb3JzLnRyYW5zYWN0aW9uUmVqZWN0ZWQocmVzcG9uc2UuZXJyb3IpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNwb25zZSA9IHJlc3BvbnNlLmhhc2g7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZXRoX3NlbmRUcmFuc2FjdGlvblwiOlxuICAgICAgICBjYXNlIFwid2FsbGV0X3NlbmRUcmFuc2FjdGlvblwiOlxuICAgICAgICAgIHJlcXVlc3RQYXJhbXMgPSBhcmdzLnBhcmFtcztcbiAgICAgICAgICByZXF1ZXN0UGFyYW1zID0gY29udmVydFNlbmRWYWx1ZXNUb0JpZ0ludChyZXF1ZXN0UGFyYW1zWzBdKTtcbiAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMud2FsbGV0LnNlbmRUcmFuc2FjdGlvbihyZXF1ZXN0UGFyYW1zKTtcbiAgICAgICAgICBpZiAocmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IHJwY0Vycm9ycy50cmFuc2FjdGlvblJlamVjdGVkKHJlc3BvbnNlLmVycm9yKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzcG9uc2UgPSByZXNwb25zZS5oYXNoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIndhbGxldF9zd2l0Y2hFdGhlcmV1bUNoYWluXCI6IHtcbiAgICAgICAgICBjb25zdCByYXdQYXJhbXMgPSBhcmdzLnBhcmFtcztcbiAgICAgICAgICBsZXQgY2hhaW5JZDtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyYXdQYXJhbXMpICYmIHJhd1BhcmFtc1swXT8uY2hhaW5JZCkge1xuICAgICAgICAgICAgY2hhaW5JZCA9IHBhcnNlSW50KHJhd1BhcmFtc1swXS5jaGFpbklkLCAxNik7XG4gICAgICAgICAgfSBlbHNlIGlmIChyYXdQYXJhbXMgJiYgdHlwZW9mIHJhd1BhcmFtcyA9PT0gXCJvYmplY3RcIiAmJiBcImlkXCIgaW4gcmF3UGFyYW1zICYmIE51bWJlci5pc0ludGVnZXIocmF3UGFyYW1zLmlkKSkge1xuICAgICAgICAgICAgY2hhaW5JZCA9IHJhd1BhcmFtcy5pZDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgcnBjRXJyb3JzLmludmFsaWRQYXJhbXMoXCJJbnZhbGlkIGNoYWluIGlkIGFyZ3VtZW50LiBFeHBlY3RlZCBbeyBjaGFpbklkOiBoZXhfc3RyaW5nIH1dIG9yIHsgaWQ6IG51bWJlciB9LlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLndhbGxldC5zd2l0Y2hDaGFpbih7IGlkOiBjaGFpbklkIH0pO1xuICAgICAgICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgICAgICAgdGhyb3cgcHJvdmlkZXJFcnJvcnMuY3VzdG9tKHsgY29kZTogNDkwMiwgbWVzc2FnZTogcmVzcG9uc2UgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF3YWl0IHRoaXMuZW1pdChcImNoYWluQ2hhbmdlZFwiLCBoZXhTdHJpbmdGcm9tTnVtYmVyKGNoYWluSWQpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZXRoX3NpZ25UeXBlZERhdGFfdjFcIjpcbiAgICAgICAgY2FzZSBcImV0aF9zaWduVHlwZWREYXRhX3YyXCI6XG4gICAgICAgIGNhc2UgXCJldGhfc2lnblR5cGVkRGF0YV92M1wiOlxuICAgICAgICBjYXNlIFwiZXRoX3NpZ25UeXBlZERhdGFfdjRcIjpcbiAgICAgICAgY2FzZSBcImV0aF9zaWduVHlwZWREYXRhXCI6IHtcbiAgICAgICAgICByZXF1ZXN0UGFyYW1zID0gYXJncy5wYXJhbXM7XG4gICAgICAgICAgY29uc3Qgc2lnbmVkVHlwZWREYXRhUGFyYW1zID0gSlNPTi5wYXJzZShyZXF1ZXN0UGFyYW1zWzFdKTtcbiAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMud2FsbGV0LnNpZ25UeXBlZERhdGEoe1xuICAgICAgICAgICAgYWNjb3VudDogcmVxdWVzdFBhcmFtc1swXSxcbiAgICAgICAgICAgIGRvbWFpbjogc2lnbmVkVHlwZWREYXRhUGFyYW1zLmRvbWFpbixcbiAgICAgICAgICAgIG1lc3NhZ2U6IHNpZ25lZFR5cGVkRGF0YVBhcmFtcy5tZXNzYWdlLFxuICAgICAgICAgICAgcHJpbWFyeVR5cGU6IHNpZ25lZFR5cGVkRGF0YVBhcmFtcy5wcmltYXJ5VHlwZSxcbiAgICAgICAgICAgIHR5cGVzOiBzaWduZWRUeXBlZERhdGFQYXJhbXMudHlwZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAocmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IHJwY0Vycm9ycy50cmFuc2FjdGlvblJlamVjdGVkKHJlc3BvbnNlLmVycm9yKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzcG9uc2UgPSByZXNwb25zZS5oYXNoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZXRoX2VjUmVjb3ZlclwiOlxuICAgICAgICBjYXNlIFwiZXRoX3N1YnNjcmliZVwiOlxuICAgICAgICBjYXNlIFwiZXRoX3Vuc3Vic2NyaWJlXCI6XG4gICAgICAgIGNhc2UgXCJwZXJzb25hbF9lY1JlY292ZXJcIjpcbiAgICAgICAgY2FzZSBcImV0aF9zaWduVHJhbnNhY3Rpb25cIjpcbiAgICAgICAgY2FzZSBcIndhbGxldF93YXRjaEFzc2V0XCI6XG4gICAgICAgIGNhc2UgXCJ3YWxsZXRfc2VuZENhbGxzXCI6XG4gICAgICAgIGNhc2UgXCJ3YWxsZXRfZ2V0Q2FsbHNTdGF0dXNcIjpcbiAgICAgICAgY2FzZSBcIndhbGxldF9nZXRDYXBhYmlsaXRpZXNcIjpcbiAgICAgICAgY2FzZSBcIndhbGxldF9zaG93Q2FsbHNTdGF0dXNcIjpcbiAgICAgICAgY2FzZSBcIndhbGxldF9ncmFudFBlcm1pc3Npb25zXCI6XG4gICAgICAgICAgdGhyb3cgcnBjRXJyb3JzLm1ldGhvZE5vdFN1cHBvcnRlZChcIk5vdCB5ZXQgaW1wbGVtZW50ZWQuXCIpO1xuICAgICAgICBjYXNlIFwiZXRoX3NpZ25cIjpcbiAgICAgICAgY2FzZSBcImV0aF9jb2luYmFzZVwiOlxuICAgICAgICBjYXNlIFwid2FsbGV0X2FkZEV0aGVyZXVtQ2hhaW5cIjpcbiAgICAgICAgICB0aHJvdyBycGNFcnJvcnMubWV0aG9kTm90U3VwcG9ydGVkKCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKCF0aGlzLndhbGxldC5jaGFpbi5ycGNVcmwpIHtcbiAgICAgICAgICAgIHRocm93IHJwY0Vycm9ycy5pbnRlcm5hbChgUlBDIFVSTCBtaXNzaW5nIGZvciBjdXJyZW50IGNoYWluICgke3RoaXMud2FsbGV0LmNoYWluLmlkfSlgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZldGNoUnBjUmVxdWVzdChhcmdzLCB0aGlzLndhbGxldC5jaGFpbi5ycGNVcmwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCB7IGNvZGUgfSA9IGVycm9yO1xuICAgICAgaWYgKGNvZGUgPT09IGVycm9yQ29kZXMucHJvdmlkZXIudW5hdXRob3JpemVkKSB7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHNlcmlhbGl6ZUVycm9yKGVycm9yKSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIG9wZW5TZXR0aW5ncygpIHtcbiAgICBhd2FpdCB0aGlzLndhbGxldD8ub3BlblNldHRpbmdzKCk7XG4gIH1cbiAgYXN5bmMgZGlzY29ubmVjdCgpIHtcbiAgICB0aGlzLndhbGxldCA9IHVuZGVmaW5lZDtcbiAgICBjb25zdCBTdG9yYWdlID0gbmV3IEdlbWluaVN0b3JhZ2U7XG4gICAgYXdhaXQgU3RvcmFnZS5yZW1vdmVJdGVtKFNUT1JBR0VfRVRIX0FDQ09VTlRTX0tFWSk7XG4gICAgYXdhaXQgU3RvcmFnZS5yZW1vdmVJdGVtKFNUT1JBR0VfRVRIX0FDVElWRV9DSEFJTl9LRVkpO1xuICAgIGF3YWl0IHRoaXMuZW1pdChcImRpc2Nvbm5lY3RcIiwgXCJVc2VyIGluaXRpYXRlZCBkaXNjb25uZWN0aW9uXCIpO1xuICB9XG59XG5leHBvcnQge1xuICB2YWxpZGF0ZVJwY1JlcXVlc3RBcmdzLFxuICB1dGY4U3RyaW5nVG9CdWZmZXIsXG4gIHNhZmVKc29uU3RyaW5naWZ5LFxuICBvcGVuUG9wdXAsXG4gIGhleFN0cmluZ0Zyb21OdW1iZXIsXG4gIGdlbmVyYXRlUmVxdWVzdElkLFxuICBmZXRjaFJwY1JlcXVlc3QsXG4gIGVuY29kZUJhc2U2NCxcbiAgZGVjb2RlQmFzZTY0LFxuICBjb252ZXJ0U2VuZFZhbHVlc1RvQmlnSW50LFxuICBjbG9zZVBvcHVwLFxuICBidWZmZXJUb0Jhc2U2NFVSTFN0cmluZyxcbiAgYmFzZTY0VG9IZXgsXG4gIFNUT1JBR0VfU01BUlRfQUNDT1VOVF9LRVksXG4gIFNUT1JBR0VfU0VUVElOR1NfS0VZLFxuICBTVE9SQUdFX1BBU1NLRVlfQ1JFREVOVElBTF9LRVksXG4gIFNUT1JBR0VfRVRIX0FDVElWRV9DSEFJTl9LRVksXG4gIFNUT1JBR0VfRVRIX0FDQ09VTlRTX0tFWSxcbiAgU0RLX1ZFUlNJT04sXG4gIFNES19CQUNLRU5EX1VSTCxcbiAgUHJvdmlkZXJFdmVudEVtaXR0ZXIsXG4gIFBPUFVQX1dJRFRILFxuICBQT1BVUF9IRUlHSFQsXG4gIEdlbWluaVdhbGxldFByb3ZpZGVyLFxuICBHZW1pbmlXYWxsZXQsXG4gIEdlbWluaVN0b3JhZ2UsXG4gIEdlbWluaVNka0V2ZW50LFxuICBERUZBVUxUX0NIQUlOX0lELFxuICBDb21tdW5pY2F0b3Jcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@gemini-wallet/core/dist/index.js\n");

/***/ })

};
;