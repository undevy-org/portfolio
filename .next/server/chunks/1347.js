"use strict";exports.id=1347,exports.ids=[1347],exports.modules={21347:(a,b,c)=>{c.d(b,{GN:()=>B});var d=c(41706),e=c(75859),f=c(22329),g=c(9132),h=c(71452),i=c(36431),j=c(79508),k=c(80796),l=c(34526),m=c(13416);let n={getGasPriceInEther:(a,b)=>Number(b*a)/1e18,getGasPriceInUSD(a,b,c){let d=n.getGasPriceInEther(b,c);return f.S.bigNumber(a).times(d).toNumber()},getPriceImpact({sourceTokenAmount:a,sourceTokenPriceInUSD:b,toTokenPriceInUSD:c,toTokenAmount:d}){let e=f.S.bigNumber(a).times(b),g=f.S.bigNumber(d).times(c);return e.minus(g).div(e).times(100).toNumber()},getMaxSlippage(a,b){let c=f.S.bigNumber(a).div(100);return f.S.multiply(b,c).toNumber()},getProviderFee:(a,b=.0085)=>f.S.bigNumber(a).times(b).toString(),isInsufficientNetworkTokenForGas:(a,b)=>!!f.S.bigNumber(a).eq(0)||f.S.bigNumber(f.S.bigNumber(b||"0")).gt(a),isInsufficientSourceTokenForSwap(a,b,c){let d=c?.find(a=>a.address===b)?.quantity?.numeric;return f.S.bigNumber(d||"0").lt(a)}};var o=c(14450),p=c(19898),q=c(13567),r=c(23115),s=c(83908),t=c(40764),u=c(60778),v=c(98604),w=c(71136),x=c(97543);let y={initializing:!1,initialized:!1,loadingPrices:!1,loadingQuote:!1,loadingApprovalTransaction:!1,loadingBuildTransaction:!1,loadingTransaction:!1,fetchError:!1,approvalTransaction:void 0,swapTransaction:void 0,transactionError:void 0,sourceToken:void 0,sourceTokenAmount:"",sourceTokenPriceInUSD:0,toToken:void 0,toTokenAmount:"",toTokenPriceInUSD:0,networkPrice:"0",networkBalanceInUSD:"0",networkTokenSymbol:"",inputError:void 0,slippage:k.oU.CONVERT_SLIPPAGE_TOLERANCE,tokens:void 0,popularTokens:void 0,suggestedTokens:void 0,foundTokens:void 0,myTokensWithBalance:void 0,tokensPriceMap:{},gasFee:"0",gasPriceInUSD:0,priceImpact:void 0,maxSlippage:void 0,providerFee:void 0},z=(0,d.BX)({...y}),A={state:z,subscribe:a=>(0,d.B1)(z,()=>a(z)),subscribeKey:(a,b)=>(0,e.u$)(z,a,b),getParams(){let a=s.W.state.activeCaipAddress,b=l.w.getPlainAddress(a),c=(0,j.K1)(),d=u.a.getConnectorId(s.W.state.activeChain);if(!b)throw Error("No address found to swap the tokens from.");let e=!z.toToken?.address||!z.toToken?.decimals,h=!z.sourceToken?.address||!z.sourceToken?.decimals||!f.S.bigNumber(z.sourceTokenAmount).gt(0),i=!z.sourceTokenAmount;return{networkAddress:c,fromAddress:b,fromCaipAddress:a,sourceTokenAddress:z.sourceToken?.address,toTokenAddress:z.toToken?.address,toTokenAmount:z.toTokenAmount,toTokenDecimals:z.toToken?.decimals,sourceTokenAmount:z.sourceTokenAmount,sourceTokenDecimals:z.sourceToken?.decimals,invalidToToken:e,invalidSourceToken:h,invalidSourceTokenAmount:i,availableToSwap:a&&!e&&!h&&!i,isAuthConnector:d===g.o.CONNECTOR_ID.AUTH}},setSourceToken(a){if(!a){z.sourceToken=a,z.sourceTokenAmount="",z.sourceTokenPriceInUSD=0;return}z.sourceToken=a,B.setTokenPrice(a.address,"sourceToken")},setSourceTokenAmount(a){z.sourceTokenAmount=a},setToToken(a){if(!a){z.toToken=a,z.toTokenAmount="",z.toTokenPriceInUSD=0;return}z.toToken=a,B.setTokenPrice(a.address,"toToken")},setToTokenAmount(a){z.toTokenAmount=a?f.S.toFixed(a,6):""},async setTokenPrice(a,b){let c=z.tokensPriceMap[a]||0;c||(z.loadingPrices=!0,c=await B.getAddressPrice(a)),"sourceToken"===b?z.sourceTokenPriceInUSD=c:"toToken"===b&&(z.toTokenPriceInUSD=c),z.loadingPrices&&(z.loadingPrices=!1),B.getParams().availableToSwap&&B.swapTokens()},switchTokens(){if(z.initializing||!z.initialized)return;let a=z.toToken?{...z.toToken}:void 0,b=z.sourceToken?{...z.sourceToken}:void 0,c=a&&""===z.toTokenAmount?"1":z.toTokenAmount;B.setSourceToken(a),B.setToToken(b),B.setSourceTokenAmount(c),B.setToTokenAmount(""),B.swapTokens()},resetState(){z.myTokensWithBalance=y.myTokensWithBalance,z.tokensPriceMap=y.tokensPriceMap,z.initialized=y.initialized,z.initializing=y.initializing,z.sourceToken=y.sourceToken,z.sourceTokenAmount=y.sourceTokenAmount,z.sourceTokenPriceInUSD=y.sourceTokenPriceInUSD,z.toToken=y.toToken,z.toTokenAmount=y.toTokenAmount,z.toTokenPriceInUSD=y.toTokenPriceInUSD,z.networkPrice=y.networkPrice,z.networkTokenSymbol=y.networkTokenSymbol,z.networkBalanceInUSD=y.networkBalanceInUSD,z.inputError=y.inputError},resetValues(){let{networkAddress:a}=B.getParams(),b=z.tokens?.find(b=>b.address===a);B.setSourceToken(b),B.setToToken(void 0)},getApprovalLoadingState:()=>z.loadingApprovalTransaction,clearError(){z.transactionError=void 0},async initializeState(){if(!z.initializing){if(z.initializing=!0,!z.initialized)try{await B.fetchTokens(),z.initialized=!0}catch(a){z.initialized=!1,x.P.showError("Failed to initialize swap"),w.I.goBack()}z.initializing=!1}},async fetchTokens(){let{networkAddress:a}=B.getParams();await B.getNetworkTokenPrice(),await B.getMyTokensWithBalance();let b=z.myTokensWithBalance?.find(b=>b.address===a);b&&(z.networkTokenSymbol=b.symbol,B.setSourceToken(b),B.setSourceTokenAmount("0"))},async getTokenList(){let a=s.W.state.activeCaipNetwork?.caipNetworkId;if(z.caipNetworkId!==a||!z.tokens)try{z.tokensLoading=!0;let b=await m.s.getTokenList(a);z.tokens=b,z.caipNetworkId=a,z.popularTokens=b.sort((a,b)=>a.symbol<b.symbol?-1:+(a.symbol>b.symbol)),z.suggestedTokens=b.filter(a=>!!k.oU.SWAP_SUGGESTED_TOKENS.includes(a.symbol))}catch(a){z.tokens=[],z.popularTokens=[],z.suggestedTokens=[]}finally{z.tokensLoading=!1}},async getAddressPrice(a){let b=z.tokensPriceMap[a];if(b)return b;let c=await r.T.fetchTokenPrice({addresses:[a]}),d=c?.fungibles||[],e=[...z.tokens||[],...z.myTokensWithBalance||[]],f=e?.find(b=>b.address===a)?.symbol,g=parseFloat((d.find(a=>a.symbol.toLowerCase()===f?.toLowerCase())?.price||0).toString());return z.tokensPriceMap[a]=g,g},async getNetworkTokenPrice(){let{networkAddress:a}=B.getParams(),b=await r.T.fetchTokenPrice({addresses:[a]}).catch(()=>(x.P.showError("Failed to fetch network token price"),{fungibles:[]})),c=b.fungibles?.[0],d=c?.price.toString()||"0";z.tokensPriceMap[a]=parseFloat(d),z.networkTokenSymbol=c?.symbol||"",z.networkPrice=d},async getMyTokensWithBalance(a){let b=await i.Z.getMyTokensWithBalance(a),c=m.s.mapBalancesToSwapTokens(b);c&&(await B.getInitialGasPrice(),B.setBalances(c))},setBalances(a){let{networkAddress:b}=B.getParams(),c=s.W.state.activeCaipNetwork;if(!c)return;let d=a.find(a=>a.address===b);a.forEach(a=>{z.tokensPriceMap[a.address]=a.price||0}),z.myTokensWithBalance=a.filter(a=>a.address.startsWith(c.caipNetworkId)),z.networkBalanceInUSD=d?f.S.multiply(d.quantity.numeric,d.price).toString():"0"},async getInitialGasPrice(){let a=await m.s.fetchGasPrice();if(!a)return{gasPrice:null,gasPriceInUSD:null};switch(s.W.state?.activeCaipNetwork?.chainNamespace){case g.o.CHAIN.SOLANA:return z.gasFee=a.standard??"0",z.gasPriceInUSD=f.S.multiply(a.standard,z.networkPrice).div(1e9).toNumber(),{gasPrice:BigInt(z.gasFee),gasPriceInUSD:Number(z.gasPriceInUSD)};case g.o.CHAIN.EVM:default:let b=a.standard??"0",c=BigInt(b),d=BigInt(15e4),e=n.getGasPriceInUSD(z.networkPrice,d,c);return z.gasFee=b,z.gasPriceInUSD=e,{gasPrice:c,gasPriceInUSD:e}}},async swapTokens(){let a=p.U.state.address,b=z.sourceToken,c=z.toToken,d=f.S.bigNumber(z.sourceTokenAmount).gt(0);if(d||B.setToTokenAmount(""),!c||!b||z.loadingPrices||!d)return;z.loadingQuote=!0;let e=f.S.bigNumber(z.sourceTokenAmount).times(10**b.decimals).round(0);try{let d=await r.T.fetchSwapQuote({userAddress:a,from:b.address,to:c.address,gasPrice:z.gasFee,amount:e.toString()});z.loadingQuote=!1;let g=d?.quotes?.[0]?.toAmount;if(!g)return void q.h.open({displayMessage:"Incorrect amount",debugMessage:"Please enter a valid amount"},"error");let h=f.S.bigNumber(g).div(10**c.decimals).toString();B.setToTokenAmount(h),B.hasInsufficientToken(z.sourceTokenAmount,b.address)?z.inputError="Insufficient balance":(z.inputError=void 0,B.setTransactionDetails())}catch(a){z.loadingQuote=!1,z.inputError="Insufficient balance"}},async getTransaction(){let{fromCaipAddress:a,availableToSwap:b}=B.getParams(),c=z.sourceToken,d=z.toToken;if(a&&b&&c&&d&&!z.loadingQuote)try{let b;return z.loadingBuildTransaction=!0,b=await m.s.fetchSwapAllowance({userAddress:a,tokenAddress:c.address,sourceTokenAmount:z.sourceTokenAmount,sourceTokenDecimals:c.decimals})?await B.createSwapTransaction():await B.createAllowanceTransaction(),z.loadingBuildTransaction=!1,z.fetchError=!1,b}catch(a){w.I.goBack(),x.P.showError("Failed to check allowance"),z.loadingBuildTransaction=!1,z.approvalTransaction=void 0,z.swapTransaction=void 0,z.fetchError=!0;return}},async createAllowanceTransaction(){let{fromCaipAddress:a,sourceTokenAddress:b,toTokenAddress:c}=B.getParams();if(a&&c){if(!b)throw Error("createAllowanceTransaction - No source token address found.");try{let d=await r.T.generateApproveCalldata({from:b,to:c,userAddress:a}),e=l.w.getPlainAddress(d.tx.from);if(!e)throw Error("SwapController:createAllowanceTransaction - address is required");let f={data:d.tx.data,to:e,gasPrice:BigInt(d.tx.eip155.gasPrice),value:BigInt(d.tx.value),toAmount:z.toTokenAmount};return z.swapTransaction=void 0,z.approvalTransaction={data:f.data,to:f.to,gasPrice:f.gasPrice,value:f.value,toAmount:f.toAmount},{data:f.data,to:f.to,gasPrice:f.gasPrice,value:f.value,toAmount:f.toAmount}}catch(a){w.I.goBack(),x.P.showError("Failed to create approval transaction"),z.approvalTransaction=void 0,z.swapTransaction=void 0,z.fetchError=!0;return}}},async createSwapTransaction(){let{networkAddress:a,fromCaipAddress:b,sourceTokenAmount:c}=B.getParams(),d=z.sourceToken,e=z.toToken;if(!b||!c||!d||!e)return;let f=t.x.parseUnits(c,d.decimals)?.toString();try{let c=await r.T.generateSwapCalldata({userAddress:b,from:d.address,to:e.address,amount:f,disableEstimate:!0}),g=d.address===a,h=BigInt(c.tx.eip155.gas),i=BigInt(c.tx.eip155.gasPrice),j=l.w.getPlainAddress(c.tx.to);if(!j)throw Error("SwapController:createSwapTransaction - address is required");let k={data:c.tx.data,to:j,gas:h,gasPrice:i,value:g?BigInt(f??"0"):BigInt("0"),toAmount:z.toTokenAmount};return z.gasPriceInUSD=n.getGasPriceInUSD(z.networkPrice,h,i),z.approvalTransaction=void 0,z.swapTransaction=k,k}catch(a){w.I.goBack(),x.P.showError("Failed to create transaction"),z.approvalTransaction=void 0,z.swapTransaction=void 0,z.fetchError=!0;return}},onEmbeddedWalletApprovalSuccess(){x.P.showLoading("Approve limit increase in your wallet"),w.I.replace("SwapPreview")},async sendTransactionForApproval(a){let{fromAddress:b,isAuthConnector:c}=B.getParams();z.loadingApprovalTransaction=!0,c?w.I.pushTransactionStack({onSuccess:B.onEmbeddedWalletApprovalSuccess}):x.P.showLoading("Approve limit increase in your wallet");try{await t.x.sendTransaction({address:b,to:a.to,data:a.data,value:a.value,chainNamespace:g.o.CHAIN.EVM}),await B.swapTokens(),await B.getTransaction(),z.approvalTransaction=void 0,z.loadingApprovalTransaction=!1}catch(a){z.transactionError=a?.displayMessage,z.loadingApprovalTransaction=!1,x.P.showError(a?.displayMessage||"Transaction error"),v.E.sendEvent({type:"track",event:"SWAP_APPROVAL_ERROR",properties:{message:a?.displayMessage||a?.message||"Unknown",network:s.W.state.activeCaipNetwork?.caipNetworkId||"",swapFromToken:B.state.sourceToken?.symbol||"",swapToToken:B.state.toToken?.symbol||"",swapFromAmount:B.state.sourceTokenAmount||"",swapToAmount:B.state.toTokenAmount||"",isSmartAccount:(0,j.lj)(g.o.CHAIN.EVM)===h.Vl.ACCOUNT_TYPES.SMART_ACCOUNT}})}},async sendTransactionForSwap(a){if(!a)return;let{fromAddress:b,toTokenAmount:c,isAuthConnector:d}=B.getParams();z.loadingTransaction=!0;let e=`Swapping ${z.sourceToken?.symbol} to ${f.S.formatNumberToLocalString(c,3)} ${z.toToken?.symbol}`,i=`Swapped ${z.sourceToken?.symbol} to ${f.S.formatNumberToLocalString(c,3)} ${z.toToken?.symbol}`;d?w.I.pushTransactionStack({onSuccess(){w.I.replace("Account"),x.P.showLoading(e),A.resetState()}}):x.P.showLoading("Confirm transaction in your wallet");try{let c=[z.sourceToken?.address,z.toToken?.address].join(","),e=await t.x.sendTransaction({address:b,to:a.to,data:a.data,value:a.value,chainNamespace:g.o.CHAIN.EVM});return z.loadingTransaction=!1,x.P.showSuccess(i),v.E.sendEvent({type:"track",event:"SWAP_SUCCESS",properties:{network:s.W.state.activeCaipNetwork?.caipNetworkId||"",swapFromToken:B.state.sourceToken?.symbol||"",swapToToken:B.state.toToken?.symbol||"",swapFromAmount:B.state.sourceTokenAmount||"",swapToAmount:B.state.toTokenAmount||"",isSmartAccount:(0,j.lj)(g.o.CHAIN.EVM)===h.Vl.ACCOUNT_TYPES.SMART_ACCOUNT}}),A.resetState(),d||w.I.replace("Account"),A.getMyTokensWithBalance(c),e}catch(a){z.transactionError=a?.displayMessage,z.loadingTransaction=!1,x.P.showError(a?.displayMessage||"Transaction error"),v.E.sendEvent({type:"track",event:"SWAP_ERROR",properties:{message:a?.displayMessage||a?.message||"Unknown",network:s.W.state.activeCaipNetwork?.caipNetworkId||"",swapFromToken:B.state.sourceToken?.symbol||"",swapToToken:B.state.toToken?.symbol||"",swapFromAmount:B.state.sourceTokenAmount||"",swapToAmount:B.state.toTokenAmount||"",isSmartAccount:(0,j.lj)(g.o.CHAIN.EVM)===h.Vl.ACCOUNT_TYPES.SMART_ACCOUNT}});return}},hasInsufficientToken:(a,b)=>n.isInsufficientSourceTokenForSwap(a,b,z.myTokensWithBalance),setTransactionDetails(){let{toTokenAddress:a,toTokenDecimals:b}=B.getParams();a&&b&&(z.gasPriceInUSD=n.getGasPriceInUSD(z.networkPrice,BigInt(z.gasFee),BigInt(15e4)),z.priceImpact=n.getPriceImpact({sourceTokenAmount:z.sourceTokenAmount,sourceTokenPriceInUSD:z.sourceTokenPriceInUSD,toTokenPriceInUSD:z.toTokenPriceInUSD,toTokenAmount:z.toTokenAmount}),z.maxSlippage=n.getMaxSlippage(z.slippage,z.toTokenAmount),z.providerFee=n.getProviderFee(z.sourceTokenAmount))}},B=(0,o.X)(A)}};