# .github/workflows/deploy.yml
# Deployment workflow using pre-built artifacts from CI pipeline
name: Deploy to DigitalOcean

on:
  workflow_run:
    workflows: ["CI Pipeline"]
    types: [completed]
    branches: [main]

jobs:
  deploy-portfolio:
    name: Deploy Portfolio App
    runs-on: ubuntu-latest
    # Only deploy if CI was successful
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    
    steps:
      # Step 1: Download artifact from CI pipeline
      - name: Step 1 - Download build artifact
        uses: actions/github-script@v7
        with:
          script: |
            // Find artifacts from the triggering workflow run
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: ${{ github.event.workflow_run.id }}
            });
            
            // Find our portfolio build artifact
            const matchArtifact = artifacts.data.artifacts.find((artifact) => {
              return artifact.name.startsWith('portfolio-build-');
            });
            
            if (!matchArtifact) {
              throw new Error('Build artifact not found');
            }
            
            // Download the artifact
            const download = await github.rest.actions.downloadArtifact({
              owner: context.repo.owner,
              repo: context.repo.repo,
              artifact_id: matchArtifact.id,
              archive_format: 'zip'
            });
            
            // Save artifact to file system
            const fs = require('fs');
            fs.writeFileSync('${{ github.workspace }}/artifact.zip', Buffer.from(download.data));
            
            console.log(`Downloaded artifact: ${matchArtifact.name}`);
            console.log(`Size: ${matchArtifact.size_in_bytes} bytes`);
      
      # Step 2: Extract and organize artifact
      - name: Step 2 - Extract and prepare build files
        run: |
          echo "üì¶ Extracting artifact..."
          mkdir extracted
          unzip -q artifact.zip -d extracted
          mv extracted/* .
          rm -rf extracted
          
          echo "üìÅ Files extracted directly to workspace:"
          ls -la
          
          echo "üìä Build directory structure:"
          if [ -d ".next" ]; then
            echo "‚úÖ .next directory found"
            du -sh .next/
          else
            echo "‚ùå .next directory not found!"
            exit 1
          fi
          
          if [ -f "package.json" ]; then
            echo "‚úÖ package.json found"
          else
            echo "‚ùå package.json not found!"
            exit 1
          fi
          
          # Create deployment bundle directory for cleaner transfer
          echo "üì¶ Creating deployment bundle..."
          mkdir -p deploy-bundle
          mv .next deploy-bundle/
          mv public deploy-bundle/ 2>/dev/null || echo "‚ö†Ô∏è  public directory not in artifact (might be expected)"
          mv package.json deploy-bundle/
          mv package-lock.json deploy-bundle/
          
          echo "‚úÖ Deployment bundle ready:"
          ls -la deploy-bundle/
      
      # Step 3: Deploy files to server
      - name: Step 3 - Deploy build files to server
        uses: appleboy/scp-action@master
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          # Now deploying from deploy-bundle directory
          source: "deploy-bundle/*"
          target: ${{ secrets.DEPLOY_PATH_PORTFOLIO }}
          # Strip the deploy-bundle prefix when copying
          strip_components: 1
      
      # Step 4: Copy source files for server-side functionality
      - name: Step 4 - Checkout code for source files
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            src
            next.config.mjs
      
      - name: Step 5 - Deploy source files to server
        uses: appleboy/scp-action@master
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          source: "src,next.config.mjs"
          target: ${{ secrets.DEPLOY_PATH_PORTFOLIO }}
      
      # Step 6: Install production dependencies and restart
      - name: Step 6 - Finalize portfolio deployment
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            export NVM_DIR="$HOME/.nvm"
            [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
            
            cd ${{ secrets.DEPLOY_PATH_PORTFOLIO }}
            
            # Install only production dependencies (no build needed!)
            echo "üì¶ Installing production dependencies..."
            npm install --production
            
            # Verify deployment
            echo "‚úÖ Verifying deployment structure:"
            if [ -d ".next" ] && [ -f "package.json" ] && [ -d "src" ]; then
              echo "‚úÖ All critical files present"
            else
              echo "‚ùå Missing critical files!"
              ls -la
              exit 1
            fi
            
            # Restart the application
            echo "üîÑ Restarting application..."
            pm2 restart ${{ secrets.PM2_APP_NAME_PORTFOLIO }}
            
            # Show application status
            pm2 status ${{ secrets.PM2_APP_NAME_PORTFOLIO }}
            
            echo "üéâ Portfolio deployment completed successfully!"
  
  deploy-bot:
    name: Deploy Telegram Bot
    runs-on: ubuntu-latest
    needs: deploy-portfolio
    # Only run if portfolio deployment succeeded
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    
    steps:
      # Step 1: Checkout repository code for bot files
      - name: Step 1 - Checkout code
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            telegram-bot
      
      # Step 2: Deploy bot files to server
      - name: Step 2 - Deploy bot files to server
        uses: appleboy/scp-action@master
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          source: "telegram-bot/*"
          target: ${{ secrets.DEPLOY_PATH_BOT_PARENT }}
      
      # Step 3: Install dependencies and restart bot
      - name: Step 3 - Finalize bot deployment
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            export NVM_DIR="$HOME/.nvm"
            [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
            
            cd ${{ secrets.DEPLOY_PATH_BOT }}
            
            # Install production dependencies
            echo "üì¶ Installing bot dependencies..."
            npm install --production
            
            # Restart the bot
            echo "üîÑ Restarting bot..."
            pm2 restart ${{ secrets.PM2_APP_NAME_BOT }}
            
            # Show bot status
            pm2 status ${{ secrets.PM2_APP_NAME_BOT }}
            
            echo "üéâ Bot deployment completed successfully!"
  
  # New job: Handle failed CI
  notify-failure:
    name: Notify CI Failure
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'failure' }}
    
    steps:
      - name: CI Failed Notification
        run: |
          echo "‚ùå CI Pipeline failed for commit ${{ github.event.workflow_run.head_sha }}"
          echo "Deployment cancelled. Fix the issues and push again."
          echo "Check the failed run: ${{ github.event.workflow_run.html_url }}"
          exit 1